# 靳氏-找工作宝典（2025）
## 一.工作岗位基础知识了解

### c++嵌入式岗位

#### 1.  c++嵌入式岗位分为哪几种，分别负责什么技术

#####  **1. 嵌入式软件开发工程师**

- **职责**：
  - 开发嵌入式系统上的应用程序（如通信协议、控制逻辑、数据处理等）。
  - 基于RTOS（实时操作系统）或裸机开发，优化代码性能和内存占用。
  - 与硬件团队协作调试，解决软硬件兼容性问题。
- **核心技术**：
  - C++（面向对象设计、资源管理、C++11/14特性）。
  - RTOS（FreeRTOS、RT-Thread、Zephyr等）。
  - [通信协议（UART/SPI/I2C、CAN、TCP/IP、MQTT等）。](https://www.nowcoder.com/discuss/718485020645552128?sourceSSR=users) 

##### 2.  嵌入式驱动开发工程师

- **职责**：
  - 编写硬件外设驱动（如传感器、显示屏、无线模块等）。
  - 调试底层硬件接口（GPIO、DMA、中断控制器）。
  - 优化驱动性能（减少延迟、提高吞吐量）。
- **核心技术**：
  - C/C++（贴近硬件的代码实现）。
  - 硬件知识（ARM Cortex-M/A系列、寄存器操作、时钟树配置）。
  - 调试工具（示波器、逻辑分析仪、JTAG/SWD）。

##### 3. 嵌入式系统架构师

- **职责**：
  - 设计嵌入式系统整体架构（硬件选型、软件分层、模块划分）。
  - 制定实时性、功耗、安全性等系统级指标。
  - 解决跨模块的技术难题（如多线程同步、内存泄漏排查）。
- **核心技术**：
  - 系统设计能力（模块化、解耦、设计模式）。
  - 多任务调度（优先级反转、死锁预防）。
  - 性能分析工具（Tracealyzer、SystemView）。

##### 4. 物联网（IOT）嵌入式开发

- **职责**：

  - 开发物联网设备端固件（如智能家居、工业传感器）。
  - 实现低功耗设计（休眠唤醒、电源管理）。
  - 对接云平台（AWS IoT、阿里云IoT）。

- **核心技术**：

  - 低功耗技术（STM32的低功耗模式、动态电压调节）。

  - 无线协议（BLE、LoRa、NB-IoT）。

  - 安全机制（TLS/DTLS、加密算法）。

    

##### 5. 汽车电子嵌入式开发

- **职责**：
  - 开发车规级ECU（电子控制单元）软件（如ADAS、车载娱乐系统）。
  - 遵循AUTOSAR架构，实现功能安全（ISO 26262）。
  - 支持CAN/LIN总线通信。
- **核心技术**：
  - AUTOSAR（BSW/SW-C分层开发）。
  - 功能安全（ASIL等级、FMEA分析）。
  - 汽车通信协议（CAN FD、DoIP、SOME/IP）。



#### 2. 研二暑假实习需要具备的技能














## 二. 真心好网站

### 1. 牛客

1[.牛客：sagima (实验室学长) 双九 最后去了 中国移动](https://www.nowcoder.com/discuss/716949192207237120?sourceSSR=users) 

### 2. 代码随想录

[代码随想录的题目](https://programmercarl.com/0704.%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE)

### 3. 二刷代码随想录，整理出自己的一套做题思路

#### 1. 数组

数组能考的题型：a=[1,2,3,4,5,6] 

查找（二分查找）

插入

删除

移动

前缀和、区间和、滑动窗口（说的好像是一件事）



##### 1. 数组理论基础

数组的存储方式：在c++中连续的一段内存地址；（查询数组内元素的时间复杂度是 0（1）插入删除元素的时间复杂度是0（n））

![image-20250212154746740](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250212154746740.png)

##### 2. [二分查找（二分查找有两种开区间和闭区间](https://programmercarl.com/0704.%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html)）  时间复杂度是  0（logn）

过了  但是注意开区间闭区间    right=mid-1;left =mid+1;  （是否加1的问题）

###### 1. [搜索插入位置（为什么返回值一定是right+1）](https://programmercarl.com/0035.%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE.html)

给定一个排序阵列和一个目标值，在阵列中找到目标值，并返回其索引。如果目标值不存在于阵列中，则返回它将被按顺序插入的位置。

![image-20250212163739835](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250212163739835.png)

###### 2. [在排序数组中查找元素的第一个和最后一个位置](https://programmercarl.com/0034.%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE.html)（通过二分查找法确实可以找到中间的位置，但怎么找到左右边界呢）（中等难度的题型） （两个二分查找单独查找）

给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。

如果数组中不存在目标值 target，返回 [-1, -1]。

进阶：你可以设计并实现时间复杂度为 $O(\log n)$ 的算法解决此问题吗？

###### 3. x的平方根（二分查找  平方从  注意数组范围）

给你一个非负整数 `x` ，计算并返回 `x` 的 **算术平方根** 。

由于返回类型是整数，结果只保留 **整数部分** ，小数部分将被 **舍去 。**

**注意：**不允许使用任何内置指数函数和算符，例如 `pow(x, 0.5)` 或者 `x ** 0.5` 。

```c++
class Solution {
public:
    int mySqrt(int x) {
        int left=0;
        int right=x;

        while(left<=right)
        {
            long long  mid=(left+right)/2; // long long 数组范围
            if(mid*mid==x) return mid;
            else if(mid*mid>x) right=mid-1;
            else  left=mid+1;
        }
        return right;
    }
};
```

###### 4. 有效的完全平方数（二分查找 简单的很）

给你一个正整数 `num` 。如果 `num` 是一个完全平方数，则返回 `true` ，否则返回 `false` 。

**完全平方数** 是一个可以写成某个整数的平方的整数。换句话说，它可以写成某个整数和自身的乘积。

不能使用任何内置的库函数，如 `sqrt` 。

##### 3. [移除元素](https://programmercarl.com/0027.%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE)（双指针法  快指针  慢指针）数组的移动和删除元素都用到双指针法。

给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。

不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并**原地**修改输入数组。

元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。

示例 1: 给定 nums = [3,2,2,3], val = 3, 函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。 你不需要考虑数组中超出新长度后面的元素。

示例 2: 给定 nums = [0,1,2,2,3,0,4,2], val = 2, 函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。

**你不需要考虑数组中超出新长度后面的元素。**

```c++
class Solution {
public:   //快慢指针法
    int removeElement(vector<int>& nums, int val) {
            int slow=0;
            for(int fast=0;fast<=nums.size()-1;fast++)
            {
                if(nums[fast]!=val)
                {
                    nums[slow]=nums[fast];
                    slow++;
                }
            }
            return slow;
    }
};
```

###### 1. 删除排序数组中的重复项( * )

给你一个 **非严格递增排列** 的数组 `nums` ，请你**[ 原地](http://baike.baidu.com/item/原地算法)** 删除重复出现的元素，使每个元素 **只出现一次** ，返回删除后数组的新长度。元素的 **相对顺序** 应该保持 **一致** 。然后返回 `nums` 中唯一元素的个数。

```c++
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        // if(nums.size()==1) return 1;

        int slow=0;
        for(int fast=1;fast<=nums.size()-1;fast++)
        {
            if(nums[slow]!=nums[fast])
            {
                    nums[++slow]=nums[fast];
            }
        }
        return slow+1;
    }
};
```

###### 2 移动零 （交换 * ）

给定一个数组 `nums`，编写一个函数将所有 `0` 移动到数组的末尾，同时保持非零元素的相对顺序。

```c++
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        int slow=0;
        for(int fast=0;fast<nums.size();fast++)
        {
            if(nums[fast])
            {
                swap(nums[slow],nums[fast]);
                slow++;
            }
           
        }

    }
};
```

###### 3  比较含退格的字符串

给定 `s` 和 `t` 两个字符串，当它们分别被输入到空白的文本编辑器后，如果两者相等，返回 `true` 。`#` 代表退格字符。

**注意：**如果对空文本输入退格字符，文本继续为空。

```c++
class Solution {
public:
    bool backspaceCompare(string s, string t) {
        
        string res=restring(s);
        string ret=restring(t);
        return res==ret;
    }
    
    string restring(string & str)
    {
        int slow=0;
        for(int  fast=0;fast<str.size();fast++)
        {
            if(str[fast]!='#')
            {
                str[slow]=str[fast];
                slow++;
            }
            else if(slow>0) slow--; //注意越界
        }
        return str.substr(0,slow);  //注意c++没有切片

    }
};
```

##### 4.  有序数组的平方 ***(既然是有序数组 那可以用双指针法)

给你一个按 **非递减顺序** 排序的整数数组 `nums`，返回 **每个数字的平方** 组成的新数组，要求也按 **非递减顺序** 排序。

- 输入：nums = [-4,-1,0,3,10]
- 输出：[0,1,9,16,100]
- 解释：平方后，数组变为 [16,1,0,9,100]，排序后，数组变为 [0,1,9,16,100]

示例 2：

- 输入：nums = [-7,-3,2,3,11]
- 输出：[4,9,9,49,121]

```c++
class Solution {
public:
    vector<int> sortedSquares(vector<int>& nums) {
        for(int i=0;i<nums.size();i++)
        {
            nums[i]*=nums[i];
        }
        sort(nums.begin(),nums.end());
        return nums;
    }
};
```

这个时间复杂度是 O(n + nlogn)， 可以说是O(nlogn)的时间复杂度，但为了和下面双指针法算法时间复杂度有鲜明对比，我记为 O(n + nlog n)。



双指针法；

```c++

        int left=0;
        int right=nums.size()-1;
        vector<int> res(nums.size(),0);
        for(int n=nums.size()-1;n>=0;n--)
        {
            if(nums[right]*nums[right]>=nums[left]*nums[left])
            {
                res[n]=nums[right]*nums[right];
                right--;
            } 
            else 
            {
                res[n]=nums[left]*nums[left];
                left++;
            }
        }
        return res;
    }
```

##### 5.长度最小的子数组*

给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的 连续 子数组，并返回其长度。如果不存在符合条件的子数组，返回 0。

示例：

- 输入：s = 7, nums = [2,3,1,2,4,3]
- 输出：2
- 解释：子数组 [4,3] 是该条件下的长度最小的子数组。

提示：

- 1 <= target <= 10^9
- 1 <= nums.length <= 10^5
- 1 <= nums[i] <= 10^5

```c++
class Solution {
public:
    int minSubArrayLen(int target, vector<int>& nums) {
        if(nums.empty()) return 0;
        int slow=0;
        int sum=0;
        int res=INT_MAX;
        for(int fast =0 ; fast<nums.size();fast++)
        {
            sum+=nums[fast];
            while(sum>=target)
            {
                res=min(res,fast-slow+1);
                sum-=nums[slow];
                slow++;
            }
        }
      
        return res==INT_MAX?0:res;
    }
};
```

###### 1.水果成蓝（中等）

你正在探访一家农场，农场从左到右种植了一排果树。这些树用一个整数数组 `fruits` 表示，其中 `fruits[i]` 是第 `i` 棵树上的水果 **种类** 。

你想要尽可能多地收集水果。然而，农场的主人设定了一些严格的规矩，你必须按照要求采摘水果：

- 你只有 **两个** 篮子，并且每个篮子只能装 **单一类型** 的水果。每个篮子能够装的水果总量没有限制。
- 你可以选择任意一棵树开始采摘，你必须从 **每棵** 树（包括开始采摘的树）上 **恰好摘一个水果** 。采摘的水果应当符合篮子中的水果类型。每采摘一次，你将会向右移动到下一棵树，并继续采摘。
- 一旦你走到某棵树前，但水果不符合篮子的水果类型，那么就必须停止采摘。

给你一个整数数组 `fruits` ，返回你可以收集的水果的 **最大** 数目

```c++
class Solution {
public:
    int totalFruit(vector<int>& fruits) {
        unordered_map<int, int> res;
        int result = 0;  // 初始化为 0，而不是 INT_MIN
        for (int left = 0, right = 0; right < fruits.size(); right++) {
            res[fruits[right]]++;  // 右指针向右扩展窗口
            // 如果水果种类超过2，左指针向右移动，直到种类数不超过2
            while (res.size() > 2) {
                res[fruits[left]]--;
                if (res[fruits[left]] == 0) {
                    res.erase(fruits[left]);
                }
                left++;
            }
            // 计算当前窗口大小并更新结果
            result = max(result, right - left + 1);
        }
        return result;
    }
};

```



###### 2.最小覆盖字串（困难）（哈希表加滑动窗口******）

给你一个字符串 `s` 、一个字符串 `t` 。返回 `s` 中涵盖 `t` 所有字符的最小子串。如果 `s` 中不存在涵盖 `t` 所有字符的子串，则返回空字符串 `""` 。

 

**注意：**

- 对于 `t` 中重复字符，我们寻找的子字符串中该字符数量必须不少于 `t` 中该字符数量。
- 如果 `s` 中存在这样的子串，我们保证它是唯一的答案。



##### 6.螺旋矩阵（中等）

给定一个正整数 n，生成一个包含 1 到 n^2 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。

示例:

输入: 3 输出: [ [ 1, 2, 3 ], [ 8, 9, 4 ], [ 7, 6, 5 ] ]

```c++
class Solution {
public:
    vector<vector<int>> generateMatrix(int n) {
        int t=0;
        int b=n-1;
        int l=0;
        int r=n-1;
        vector<vector<int>> res(n,vector<int>(n,0)); //初始化
        int num=1;

        while(num<=n*n)
        {
            for(int i=l;i<=r;i++)
            {
                res[t][i]=num++;
            }
            t++;
            for(int i=t;i<=b;i++)
            {
                res[i][r]=num++;
            }
            r--;
            for(int i=r;i>=l;i--)
            {
                res[b][i]=num++;
            }
            b--;

            for(int i=b;i>=t;i--)
            {
                res[i][l]=num++;
            }
            l++;
        }
        return res;
    }
};
```

###### 1.螺旋矩阵

给你一个 `m` 行 `n` 列的矩阵 `matrix` ，请按照 **顺时针螺旋顺序** ，返回矩阵中的所有元素。

 

```c++
class Solution {
public:
    vector<int> spiralOrder(vector<vector<int>>& matrix) {
        int t=0;
        int l=0;
        int b=matrix.size()-1;
        int r=matrix[0].size()-1;
        vector<int> res(matrix.size()*matrix[0].size(),0);
        int index=0;
        while(index<(matrix.size()*matrix[0].size()))
        {
            for(int i=l;i<=r;i++)
            {
                res[index++]=matrix[t][i];
            }
            t++;

            for(int i=t;i<=b;i++)
            {
                res[index++]=matrix[i][r];
            }
            r--;

            //在更新边界时，程序可能会重复访问已经处理过的元素，尤其是在矩阵维度较小（如行数或列数为 1）时。为了避免这种情况，您需要在每个循环时检查是否有剩余的行或列进行处理。

            
            if(t<=b)  // 如果仍然有行剩余
            {
                for(int i=r;i>=l;i--)
                {
                    res[index++]=matrix[b][i];
                }
                b--;                
            }
            if(l<=r)   // 如果仍然有列剩余
            {
                for(int i=b;i>=t;i--)
                {
                    res[index++]=matrix[i][l];
                }
                l++;          

            }

        }
        return res;
    }
};
```



###### 2.螺旋遍历二维数组 //同上

给定一个二维数组 `array`，请返回「**螺旋遍历**」该数组的结果。

**螺旋遍历**：从左上角开始，按照 **向右**、**向下**、**向左**、**向上** 的顺序 **依次** 提取元素，然后再进入内部一层重复相同的步骤，直到提取完所有元素。

 ##### 7.区间和

给定一个整数数组 Array，请计算该数组在每个指定区间内元素的总和。

输入描述

第一行输入为整数数组 Array 的长度 n，接下来 n 行，每行一个整数，表示数组的元素。随后的输入为需要计算总和的区间，直至文件结束。

输出描述

输出每个指定区间内元素的总和。

输入示例

```c++
#include<iostream>
#include<vector>
using namespace std;

int main()
{
    int n=0;
    cin>>n;
    vector<int> num(n,0);
    vector<int> sum(n,0);
    int add=0;
    for(int i=0;i<n;i++)
    {
        cin>>num[i];
        add+=num[i];
        sum[i]=add;
        // cout<<sum[i];
    }
    int l,r;
    while(cin>>l>>r)   //错误
    {
            
            if(l!=0)    cout<<sum[r]-sum[l-1]<<endl;
            else cout<<sum[r]<<endl;
    }  
        
    }

```





##### 8.开发商购买土地(单独求出行和和列和)（** 没看完）

【题目描述】

在一个城市区域内，被划分成了n * m个连续的区块，每个区块都拥有不同的权值，代表着其土地价值。目前，有两家开发公司，A 公司和 B 公司，希望购买这个城市区域的土地。

现在，需要将这个城市区域的所有区块分配给 A 公司和 B 公司。

然而，由于城市规划的限制，只允许将区域按横向或纵向划分成两个子区域，而且每个子区域都必须包含一个或多个区块。

为了确保公平竞争，你需要找到一种分配方式，使得 A 公司和 B 公司各自的子区域内的土地总价值之差最小。

注意：区块不可再分。

【输入描述】

第一行输入两个正整数，代表 n 和 m。

接下来的 n 行，每行输出 m 个正整数。

输出描述

请输出一个整数，代表两个子区域内土地总价值之间的最小差距。

【输入示例】

3 3 1 2 3 2 1 3 1 2 3

【输出示例】

0

【提示信息】

如果将区域按照如下方式划分：

1 2 | 3 2 1 | 3 1 2 | 3

两个子区域内土地总价值之间的最小差距可以达到 0。

【数据范围】：

- 1 <= n, m <= 100；
- n 和 m 不同时为 1。



####  2   链表

（移除链表元素、设计链表、反转链表、两两交换链表中节点、删除链表倒数N个节点、链表香蕉、环形链表、）

链表最好设置一个虚拟节点指向头节点操作

##### 1.链表理论基础



![image-20250214083938791](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250214083938791.png)

![image-20250214084012858](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250214084012858.png)

![image-20250214084038739](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250214084038739.png)





![image-20250213191232339](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250213191232339.png)

![image-20250213191253157](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250213191253157.png)

######  链表的存储方式（非连续）

链表在内存中的存储非连续  散乱分布，分配机制取决于内存管理机制

![image-20250213191550384](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250213191550384.png)

###### 链表的定义（******）

```c++
struct ListNode{
int val; //节点上存储的元素
ListNode *next;//指向下一个节点的指针
ListNode(int x):val(x),next(Null){}//节点的构造函数
};

```

![image-20250213192115567](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250213192115567.png)



```c++
//通过自定义的构造函数给ListNode节点赋值
ListNode *next= new ListNode(5);
//使用默认的构造函数
ListNode *next=new ListNode();
next->val=5;
//所以如果不定义构造函数使用默认构造函数的话，在初始化的时候就不能直接给变量赋值！

```

###### 链表的操作（查找的时间复杂度为0（n）添加等操作位o(1)）

删除  新增节点  替换  

![image-20250213193705224](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250213193705224.png)

![链表-链表与数据性能对比](https://code-thinking-1253855093.file.myqcloud.com/pics/20200806195200276.png)

数组在定义的时候，长度就是固定的，如果想改动数组的长度，就需要重新定义一个新的数组。

链表的长度可以是不固定的，并且可以动态增删， 适合数据量不固定，频繁增删，较少查询的场景。

相信大家已经对链表足够的了解，后面我会讲解关于链表的高频面试题目，我们下期见！



##### 2.移除链表元素

```c++
 //定义单链表
 struct ListNode{
    int val;
    ListNode *next;
    ListNode(int x):val(x),next(nullptr){}
    ListNode():val(0),next(nullptr){}
    ListNode(int x,ListNode *next):val(x),next(next){}
 };
```

![image-20250213202345007](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250213202345007.png)

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */

//  //定义单链表
//  struct ListNode{
//     int val;
//     ListNode *next;
//     ListNode(int x):val(x),next(nullptr){}
//     ListNode():val(0),next(nullptr){}
//     ListNode(int x,ListNode *next):val(x),next(next){}
//  };

class Solution {
public:
    ListNode* removeElements(ListNode* head, int val) {
        ListNode * dummyHead= new ListNode(0);  //虚拟头节点
        dummyHead->next=head;
            ListNode * cur=dummyHead;
        while(cur->next!=nullptr)
        {
            if(cur->next->val==val)
            {
                ListNode * temp=cur->next;
                cur->next=temp->next;
                delete(temp);
            }
            else{
                cur=cur->next;
            }
        }
        return dummyHead->next;
    }
};
```

##### 3.设计链表

题意：

在链表类中实现这些功能：

- get(index)：获取链表中第 index 个节点的值。如果索引无效，则返回-1。
- addAtHead(val)：在链表的第一个元素之前添加一个值为 val 的节点。插入后，新节点将成为链表的第一个节点。
- addAtTail(val)：将值为 val 的节点追加到链表的最后一个元素。
- addAtIndex(index,val)：在链表中的第 index 个节点之前添加值为 val 的节点。如果 index 等于链表的长度，则该节点将附加到链表的末尾。如果 index 大于链表长度，则不会插入节点。如果index小于0，则在头部插入节点。
- deleteAtIndex(index)：如果索引 index 有效，则删除链表中的第 index 个节点。

```c++
class MyLinkedList {
public:
    // 定义链表节点结构体
    struct LinkedNode {
        int val;
        LinkedNode* next;
        LinkedNode(int val):val(val), next(nullptr){}
    };

    // 初始化链表
    MyLinkedList() {
        _dummyHead = new LinkedNode(0); // 这里定义的头结点 是一个虚拟头结点，而不是真正的链表头结点
        _size = 0;
    }

    // 获取到第index个节点数值，如果index是非法数值直接返回-1， 注意index是从0开始的，第0个节点就是头结点
    int get(int index) {
        if (index > (_size - 1) || index < 0) {
            return -1;
        }
        LinkedNode* cur = _dummyHead->next;
        while(index--){ // 如果--index 就会陷入死循环
            cur = cur->next;
        }
        return cur->val;
    }

    // 在链表最前面插入一个节点，插入完成后，新插入的节点为链表的新的头结点
    void addAtHead(int val) {
        LinkedNode* newNode = new LinkedNode(val);
        newNode->next = _dummyHead->next;
        _dummyHead->next = newNode;
        _size++;
    }

    // 在链表最后面添加一个节点
    void addAtTail(int val) {
        LinkedNode* newNode = new LinkedNode(val);
        LinkedNode* cur = _dummyHead;
        while(cur->next != nullptr){
            cur = cur->next;
        }
        cur->next = newNode;
        _size++;
    }

    // 在第index个节点之前插入一个新节点，例如index为0，那么新插入的节点为链表的新头节点。
    // 如果index 等于链表的长度，则说明是新插入的节点为链表的尾结点
    // 如果index大于链表的长度，则返回空
    // 如果index小于0，则在头部插入节点
    void addAtIndex(int index, int val) {

        if(index > _size) return;
        if(index < 0) index = 0;        
        LinkedNode* newNode = new LinkedNode(val);
        LinkedNode* cur = _dummyHead;
        while(index--) {
            cur = cur->next;
        }
        newNode->next = cur->next;
        cur->next = newNode;
        _size++;
    }

    // 删除第index个节点，如果index 大于等于链表的长度，直接return，注意index是从0开始的
    void deleteAtIndex(int index) {
        if (index >= _size || index < 0) {
            return;
        }
        LinkedNode* cur = _dummyHead;
        while(index--) {
            cur = cur ->next;
        }
        LinkedNode* tmp = cur->next;
        cur->next = cur->next->next;
        delete tmp;
        //delete命令指示释放了tmp指针原本所指的那部分内存，
        //被delete后的指针tmp的值（地址）并非就是NULL，而是随机值。也就是被delete后，
        //如果不再加上一句tmp=nullptr,tmp会成为乱指的野指针
        //如果之后的程序不小心使用了tmp，会指向难以预想的内存空间
        tmp=nullptr;
        _size--;
    }

    // 打印链表
    void printLinkedList() {
        LinkedNode* cur = _dummyHead;
        while (cur->next != nullptr) {
            cout << cur->next->val << " ";
            cur = cur->next;
        }
        cout << endl;
    }
private:
    int _size;
    LinkedNode* _dummyHead;

};
```

##### 4. 反转链表



题意：反转一个单链表。

示例: 输入: 1->2->3->4->5->NULL 输出: 5->4->3->2->1->NULL

![image-20250213212656819](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250213212656819.png)

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        ListNode *cur=NULL;
        ListNode *pre=head;
        while(pre!=NULL)
        {
            ListNode *temp=pre->next;
            pre->next=cur;
            cur=pre;
            pre=temp;

        }
        return cur;
    }
};
```

##### 5. 两两交换链表中的节点

给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。

你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。

![24.两两交换链表中的节点-题意](https://code-thinking.cdn.bcebos.com/pics/24.%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9-%E9%A2%98%E6%84%8F.jpg)

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
        ListNode *dummyNode= new ListNode(0);
        dummyNode->next=head;
        ListNode *cur=dummyNode;
        while(cur->next!=nullptr && cur->next->next!=nullptr)
        {
            ListNode *node1=cur->next;
            ListNode *node2=node1->next;
            ListNode *node3=node2->next;
            cur->next=node2;
            node2->next=node1;
            node1->next=node3;
            cur=node1;

        }
        return dummyNode->next;

    }
};
```

##### 6. 删除链表的倒数第N个节点（双指针的经典应用）

给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。

进阶：你能尝试使用一趟扫描实现吗？  （只要想到 fast 和slow 之间的距离是n就行  fast到迷哦卫视删除slow）

![image-20250213214603674](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250213214603674.png)

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        ListNode * dummyHead= new ListNode(0);
        dummyHead->next=head;
        ListNode *fast=dummyHead;
        ListNode *slow=dummyHead;
        for(int i=0;i<n;i++) //多走一步  n+1
        {
            fast=fast->next;
        }
        while(fast->next!=nullptr)
        {
            fast=fast->next;
            slow=slow->next;
        }
        ListNode *temp=slow->next;
        slow->next=temp->next;
        delete temp;
        return dummyHead->next; //代码本身是正确的，但是返回的应该是 dummyHead->next 而不是 head。因为如果删除的是链表的第一个节点，head 会发生变化，返回 dummyHead->next 才能确保返回正确的链表头。
    }
};

```

##### 7.链表相交(双指针 ** )

```c++

        //双指针法
        if(headA==NULL || headB==NULL)
        {
            return NULL;
        }
        ListNode *pA=headA;
        ListNode *pB=headB;
        while(pA!=pB)
        {
            pA=pA==NULL?headB:pA->next;
            pB=pB==NULL?headA:pB->next;
        }
        return pA;
```



给你两个单链表的头节点 headA 和 headB ，请你查找并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。

图标两个链表在节点c1开始相交：

![img](https://code-thinking-1253855093.file.myqcloud.com/pics/20211219221657.png)

题目数据保证整个链式结构中不存在环。

注意，函数返回结果后，链表必须保持其原始结构。

示例1：

![img](https://code-thinking-1253855093.file.myqcloud.com/pics/20211219221723.png)

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public://哈希表  地址相同
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        unordered_map<ListNode* ,int> list1;

        ListNode *dummyHead1=new ListNode(0);
        dummyHead1->next=headA;
        ListNode *cur=dummyHead1;
        while(cur->next!=NULL)
        {
            list1[cur->next]++;
            cur=cur->next;
        }

        ListNode *dummyHead2=new ListNode(0);
        dummyHead2->next=headB;
        ListNode *cur2=dummyHead2;
        while(cur2->next!=NULL)
        {
            if(list1.find(cur2->next)!=list1.end())
            {
                return cur2->next;
            }
            cur2 = cur2->next;  // 移动cur2
        }
        return NULL;
    }
};
```

##### 8.环形链表II(哈希表   秒了)

题意：给定一个链表，返回链表开始入环的第一个节点。如果链表无环，则返回null。

为了表示给定链表中的环，用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 pos 为 -1，则如果该链表中没有环。

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:  //哈希表集地址
    ListNode *detectCycle(ListNode *head) {
        unordered_map<ListNode*,int> cnt;
        ListNode* dummyHead=new ListNode(0);
        dummyHead->next=head;
        ListNode* cur=dummyHead;
        while(cur->next!=NULL)
        {
            if(cnt.find(cur->next)!=cnt.end()) return cur->next;
            cnt[cur->next]++;
            cur=cur->next;

        }
        return NULL;
    }
};
```

#### 3. 哈希表

##### 1. [哈希表理论基础](https://programmercarl.com/%E5%93%88%E5%B8%8C%E8%A1%A8%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0)

###### 常见的三种哈希结构

当我们想使用哈希法来解决问题的时候，我们一般会选择如下三种数据结构。

- 数组
- set （集合）
- map(映射)

这里数组就没啥可说的了，我们来看一下set。

​     ![image-20250214102148824](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250214102148824.png)

![image-20250214102339555](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250214102339555.png)



总结一下，**当我们遇到了要快速判断一个元素是否出现集合里的时候，就要考虑哈希法**。

但是哈希法也是**牺牲了空间换取了时间**，因为我们要使用额外的数组，set或者是map来存放数据，才能实现快速的查找。

如果在做面试题目的时候遇到需要判断一个元素是否出现过的场景也应该第一时间想到哈希法

##### 2. 有效的字母异位词*（注意当开两个字符串长度不相等时）

给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。

示例 1: 输入: s = "anagram", t = "nagaram" 输出: true

示例 2: 输入: s = "rat", t = "car" 输出: false

**说明:** 你可以假设字符串只包含小写字母

```c++
class Solution {
public:
    bool isAnagram(string s, string t) {
        //长度不相等时
        if(s.size()!=t.size()) return false;
        unordered_map<char,int> map_s;
        for(char c:s)
        {
            map_s[c]++;
        }
        for(char c:t)
        {
            if(map_s.find(c)!=map_s.end())
            {
                 map_s[c]--;
                if(map_s[c]==0)
                { map_s.erase(c);}
            }
            else return false;

        }
        return true;


    }
};
```

###### 1. 赎金信（和上一题代码一样）

![image-20250214105227120](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250214105227120.png)

###### 2. 字母异位词分组

![image-20250214105528916](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250214105528916.png)

```c++
class Solution {
public:
    vector<vector<string>> groupAnagrams(vector<string>& strs) {
        
        //给每个子字符串排序，直接判断相等
        vector<vector<string>> res;
        // vector<string> temp;
        unordered_map<string,vector<string>> set_res;
        for(int i=0;i<strs.size();i++)
        {
            string temp=strs[i];
            sort(temp.begin(),temp.end());
            set_res[temp].push_back(strs[i]);
        }
        //遍历map
        while(set_res.size()!=0)
        {
            res.push_back(set_res[set_res.begin()->first]);
            set_res.erase(set_res.begin()->first);
        }
        return res;



    }
};
```



###### 3. 找到字符串中所有字母异位词

![image-20250214172443780](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250214172443780.png)

```c++
class Solution {
public:
    vector<int> findAnagrams(string s, string p) {
        //滑动窗口法    p.size对比
        int s_size=s.size();
        int p_size=p.size();
        vector<int> s_map(26,0);//长度26  初始次数为0
        vector<int> p_map(26,0);
        vector<int> res;
        for(int i=0;i<p_size;i++)
        {
            p_map[p[i]-'a']++;
        }
        int left=0;
        // int right=p_size()-1;
        for(int right=0;right<=s_size-1;right++)
        {
            s_map[s[right]-'a']++;
            if(right-left+1>=p_size)
            {
                if(s_map==p_map)
                {
                    res.push_back(left);
                }
                
                s_map[s[left]-'a']--;
                left++;
            }
        }
        return res;


    }

};
```

##### 3.两数组的交集

![image-20250218094221491](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250218094221491.png)

```c++
class Solution {
public:
    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {
        unordered_map<int,int> n1;
        for(int i=0;i<nums1.size();i++)
        {
                n1[nums1[i]]++;
        }

        vector<int> res;
        for(int i=0;i<nums2.size();i++)
        {
            if(n1.find(nums2[i])!=n1.end())
            {
                res.push_back(nums2[i]);
                n1[nums2[i]]=0;
                 n1.erase(nums2[i]);
            }
        }
        return res;
    }
};
```

###### 数组交集2

![image-20250218094300426](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250218094300426.png)

```c++
// class Solution {
// public:
//     vector<int> intersect(vector<int>& nums1, vector<int>& nums2) {
        
//     }
// };


class Solution {
public:
    vector<int> intersect(vector<int>& nums1, vector<int>& nums2) {
        unordered_map<int,int> n1;
        for(int i=0;i<nums1.size();i++)
        {
                n1[nums1[i]]++;
        }

        vector<int> res;
        for(int i=0;i<nums2.size();i++)
        {
            if(n1.find(nums2[i])!=n1.end())
            {
                res.push_back(nums2[i]);
                n1[nums2[i]]--;
                if(n1[nums2[i]]==0) n1.erase(nums2[i]);
            }
        }
        return res;
    }
};
```

##### 4. 快乐数

![image-20250218094331293](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250218094331293.png)

```c++
class Solution {
public:
    bool isHappy(int n) {
        unordered_map<int,int> res;

        while(n!=1)
        {
            int cnt=fun(n);
            if(cnt==n) return true;
            if(res.find(cnt)!=res.end())
            {
                return false;
            }
            res[cnt]++;
            n=cnt;
        }
        return true;

    }

    long long fun(int num)
    {   int temp=0;
    int last=0;
        while( num>0)
        {
            last=num%10;//取出最后一位
            num/=10;//去掉最后一位
            temp+=last*last;
        }
        return temp;
    }
};
```

##### 5.两数之和

![image-20250218094416728](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250218094416728.png)

![image-20250218094429678](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250218094429678.png)

```c++
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        vector<int> res;
        unordered_map<int,int> cnt;
        for(int i=0;i<nums.size();i++)
        {
            int temp=target-nums[i];
            auto it=cnt.find(temp);
            if(it!=cnt.end())
            {
                return {it->second,i};
            }
            cnt[nums[i]]=i;
        }
        return {0,0};
    }
};
```

##### 6. 四数相加

![image-20250218094525655](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250218094525655.png)



```c++
class Solution {
public:
    int fourSumCount(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3, vector<int>& nums4) {
        //两两组合 
        unordered_map<int,int> compos1;
        int count=0;
        // unoedered_map<int,int> compos2;
        for(int i=0;i<nums1.size();i++)
        {
            for(int j=0;j<nums2.size();j++)
            {
                compos1[nums1[i]+nums2[j]]++;
            }
        }
        for(int i=0;i<nums3.size();i++)
        {
            for(int j=0;j<nums4.size();j++)
            {
                int target=-nums3[i]-nums4[j];
               if(compos1.find(target)!=compos1.end())
               {
                    count+=compos1[target];
   
               }
            }
        }
        return count;

    }
};
```



##### 7. 赎金信

![image-20250218100330374](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250218100330374.png)

```

```



##### 8. 三数之和 （一个数组里面k数和 = 0 ）

（三指针）

![image-20250218100445749](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250218100445749.png)

```c++
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        vector<vector<int>> res;
        sort(nums.begin(), nums.end());  // 排序

        for (int i = 0; i < nums.size(); i++) {
            // 跳过重复的元素，避免结果重复
            if (i > 0 && nums[i] == nums[i - 1]) continue;

            int left = i + 1, right = nums.size() - 1;
            while (left < right) {
                int sum = nums[i] + nums[left] + nums[right];
                if (sum == 0) {
                    res.push_back({nums[i], nums[left], nums[right]});
                    // 跳过重复的元素
                    while (left < right && nums[left] == nums[left + 1]) left++;
                    while (left < right && nums[right] == nums[right - 1]) right--;
                    left++;
                    right--;
                } else if (sum < 0) {
                    left++;  // 需要更大的数
                } else {
                    right--;  // 需要更小的数
                }
            }
        }

        return res;
    }
};

```

##### 8. 四数之和   (  和三数和一样要重新做)

![image-20250218105352327](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250218105352327.png)

```c++
class Solution {
public:
    vector<vector<int>> fourSum(vector<int>& nums, int target) {
        ranges::sort(nums);
        vector<vector<int>> ans;
        int n = nums.size();
        for (int a = 0; a < n - 3; a++) { // 枚举第一个数
            long long x = nums[a]; // 使用 long long 避免溢出
            if (a > 0 && x == nums[a - 1]) continue; // 跳过重复数字
            if (x + nums[a + 1] + nums[a + 2] + nums[a + 3] > target) break; // 优化一
            if (x + nums[n - 3] + nums[n - 2] + nums[n - 1] < target) continue; // 优化二
            for (int b = a + 1; b < n - 2; b++) { // 枚举第二个数
                long long y = nums[b];
                if (b > a + 1 && y == nums[b - 1]) continue; // 跳过重复数字
                if (x + y + nums[b + 1] + nums[b + 2] > target) break; // 优化一
                if (x + y + nums[n - 2] + nums[n - 1] < target) continue; // 优化二
                int c = b + 1, d = n - 1;
                while (c < d) { // 双指针枚举第三个数和第四个数
                    long long s = x + y + nums[c] + nums[d]; // 四数之和
                    if (s > target) d--;
                    else if (s < target) c++;
                    else { // s == target
                        ans.push_back({(int) x, (int) y, nums[c], nums[d]});
                        for (c++; c < d && nums[c] == nums[c - 1]; c++); // 跳过重复数字
                        for (d--; d > c && nums[d] == nums[d + 1]; d--); // 跳过重复数字
                    }
                }
            }
        }
        return ans;
    }
};


```







## 三、基础知识

### [【技能进阶1】面试不问，默认你会的技能：Git](https://www.nowcoder.com/discuss/683719113209864192)

### [【技能进阶2】面试不问，默认你会的技能：Docker](https://www.nowcoder.com/discuss/685505400984076288)

### [【技能进阶3】面试不问，默认你会的技能：Linux命令](https://www.nowcoder.com/discuss/702840449987301376?sourceSSR=users)

### [嵌入式模拟面试拷打【1】](https://www.nowcoder.com/discuss/656162857771364352?sourceSSR=search)

### [嵌入式模拟面试拷打【2】](https://www.nowcoder.com/discuss/658621010672943104?sourceSSR=search)

### [嵌入式模拟面试拷打【3】](https://www.nowcoder.com/discuss/659372083679395840?sourceSSR=search)

### [嵌入式模拟面试拷打【4】](https://www.nowcoder.com/discuss/665962511342059520?sourceSSR=search)

### [嵌入式模拟面试拷打【5】](https://www.nowcoder.com/discuss/668405148430958592?sourceSSR=search)

### [嵌入式模拟面试拷打【6】](https://www.nowcoder.com/discuss/668841553929994240?sourceSSR=search)

### [嵌入式模拟面试拷打【7】](https://www.nowcoder.com/discuss/682174283287670784?sourceSSR=users)

### [嵌入式模拟面试拷打【8】](https://www.nowcoder.com/discuss/682174899556732928?sourceSSR=users)

### [嵌入式模拟面试拷打【9】Linux系统性能问题排查思路](https://www.nowcoder.com/discuss/703272482492387328?sourceSSR=search)

### [嵌入式模拟面试拷打【10】Linux典型的故障处理场景](https://www.nowcoder.com/discuss/704610682431442944?sourceSSR=search)

### [嵌入式模拟面试拷打【11】操作系统](https://www.nowcoder.com/discuss/659372831020482560?sourceSSR=search)

### [嵌入式模拟面试拷打【12】Docker](https://www.nowcoder.com/discuss/684451200497897472?sourceSSR=search)

### [嵌入式模拟面试拷打【13】：SPI、UART、I2C通信的定义、应用与区别SPI、UART、I2C通信的定义、应用与区别](https://www.nowcoder.com/discuss/718485020645552128?sourceSSR=search)

### [AI大模型面试模拟拷打](https://www.nowcoder.com/discuss/694476338157076480?sourceSSR=search)



### c++基础语法（我的笔记上）

### 常规八股: [小林coding](https://xiaolincoding.com/)，操作系统，计网，数据库

![image-20250214152157297](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250214152157297.png)

## 四、预备做的项目

### [1. 手写操作系统项目 | 代码随想录](https://www.programmercarl.com/other/project_os.html#%E9%A1%B9%E7%9B%AE%E6%96%87%E6%A1%A3%E8%8E%B7%E5%8F%96%E6%96%B9%E5%BC%8F)  Mit6.s081



操作系统本身就是面试的必考知识，**尤其是面试后端开发、嵌入式开发等岗位时，更是如此**。

同时操作系统也是一个很不错的项目，如果是C++选手做这个项目的话，既可以用来投后端岗位，也可以投 嵌入式岗位，都是比较匹配的。

如果想好好学习操作系统，一定绕不开 Mit6.s081。

Mit6.s081 是麻省理工学院面向本科生的操作系统课程，其课程实验是在教学用操作系统xv6上进行扩展和优化。

Xv6 操作系统源代码只有一万余行，并且相对清晰和模块化，每个 lab 都带有自动评测功能，非常适合用于实践操作系统知识。

这是大家公认的高质量操作系统实践课。

项目代码全部开源，github地址：[https://github.com/youngyangyang04/KamaOS(opens new window)](https://github.com/youngyangyang04/KamaOS)

欢迎star，fork，去学习一波。

星球项目文档就分享在[知识星球](https://www.programmercarl.com/other/kstar.html)里。

今年秋招已经有录友用这个项目拿到offer了 ：



![image-20250214162256298](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250214162256298.png)

### 2. WebServer

为什么推荐做 WebServer？

1、**cpper 能够找到的项目（有详细资料的）确实不多**

对于科班 or 有充足实习经历 or 课题组项目丰富的同学来说，自然有许多相关的项目能够写在简历上。

但是对于项目经历贫乏的cpp转码选手来说，在网上能够找到的项目（有较详细资料的），无非就是比较简单的xx管理系统、五子棋等简易游戏、各种工具库、烂大街的WebServer，然后你就可以发现里面最高大上的还是 WebServer（还有个 RPC 框架）。

2、**能够将面试所需的基础知识串联起来**

WebServer 能够串联绝大部分的面试八股，语言（C/C++全覆盖，可以扩展至C++11/17）+操作系统（含有大量的 I/O 系统调用及其封装。

还有 EPOLL 等多路复用机制）+计算机网络（本身就是一个网络框架，对网络异常的处理）+数据库（注册中心的数据库语句、负载均衡等）。

当你的项目中涵盖了所有面试所需的基础知识后，面试官更倾向结合你的项目去考察知识，而不是东问一个西问一个，**这样可以将面试的问题限制在一定的范围中，一定程度上降低了面试准备的难度**。

3、**万物均能集成到 WebServer 中**

WebServer 的本质上是一个高性能网络框架，它提供了一个单服务端（当然也可以扩展为多服务端）与多客户端的高效连接框架，但是客户端与服务端连接上以后具体应该做些什么（也就是有哪些业务），这就可以由我们自由发挥了，这就是 WebServer 的功能扩展。

目前大多数的 WebServer 都将从服务端获取 MIME 作为主要功能。

但实际上，之前说到的游戏可以放到上面（是不是就有点像对战平台了），管理系统可以放到上面、存储引擎（卡哥的skipList：https://github.com/youngyangyang04/Skiplist-CPP ）等你能想到的都可以部署在 WebServer 上，这样看来，WebServer 本身具备相当的工作量。





## 正点原子视频



![6379727a431814e5f9a8db0f77dade5](D:\Program Files\wechat\WeChat Files\wxid_28c7brmd4irv22\FileStorage\Temp\6379727a431814e5f9a8db0f77dade5.png)

### [1. 正点原子 STM32](https://www.bilibili.com/video/BV1Lx411Z7Qa?spm_id_from=333.788.player.switch&vd_source=54dd3357d0d4c6dad497adff49640adf&p=2)

![72ee43410f131970582beb7edc11b39](D:\Program Files\wechat\WeChat Files\wxid_28c7brmd4irv22\FileStorage\Temp\72ee43410f131970582beb7edc11b39.jpg)

![b091fd560843bf81e2d83c1026d8cd8](D:\Program Files\wechat\WeChat Files\wxid_28c7brmd4irv22\FileStorage\Temp\b091fd560843bf81e2d83c1026d8cd8.jpg)

![ad162fe67602cb3e097a3b1260ce2b0](D:\Program Files\wechat\WeChat Files\wxid_28c7brmd4irv22\FileStorage\Temp\ad162fe67602cb3e097a3b1260ce2b0.jpg)







#### 5.第五讲

![image-20250218200528488](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250218200528488.png)

什么是ARM内核





###### 什么是stm32

![image-20250218200720096](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250218200720096.png)





###### cortex内核

![image-20250218201223251](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250218201223251.png)

###### stm32 vs ARM7



![image-20250218201728099](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250218201728099.png)

![image-20250218201955840](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250218201955840.png)![image-20250218202049808](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250218202049808.png)

![image-20250218202108887](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250218202129584.png)

##### stm32概述

###### 1.cm3芯片结构

![image-20250218202353967](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250218202353967.png)

###### 2.1 CM3芯片结构



###### 2.2 STM32F10x的2个产品线介绍



###### 2.3 STM32F10x各芯片之间的关联

![image-20250218203342598](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250218203342598.png)

###### 2.4 STM32命名规则

![image-20250218203201154](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250218203201154.png)

![image-20250218203311194](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250218203311194.png)

###### 3 .1应用





![image-20250218203458060](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250218203458060.png)

###### 3.2优势

![image-20250218203747275](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250218203747275.png)



#### 6.第六讲 STM32芯片解读

![image-20250218204323778](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250218204323778.png)





#####  1.芯片有哪些资源?

![image-20250218204440870](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250218204440870.png)

![image-20250218204550356](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250218204550356.png)



![image-20250218204818834](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250218204818834.png)

![image-20250218204849546](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250218204849546.png)

![image-20250218205053862](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250218205053862.png)

![image-20250218205210430](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250218205210430.png)

![image-20250218205246610](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250218205246610.png)





##### 2.芯片内部结构怎样?

![image-20250218205349715](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250218205349715.png)



![image-20250218205557538](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250218205557538.png)



##### 3.芯片引脚和功能怎么对应?





##### 4.STM32最小系统设计



![image-20250218210405313](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250218210405313.png)

#### 7.第七讲   开发环境搭建

##### 1.MDK软件安装



![image-20250218211158364](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250218211158364.png)



##### 2.USB串口驱动安装



##### 3.JLINK驱动安装

####  8.第八讲（串口下载程序）

#### 9.第九讲  JLINK程序下载

#### 10.新建库函数模板

![image-20250218212446802](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250218212446802.png)

#### 11. 第十一讲 新建寄存器模板



#### 12.  *  第十二讲 GPIO基本原理和寄存器配置

##### 1. GPIO基本结构和工作方式

![](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250218215836474.png)

![image-20250218215923596](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250218215923596.png)



![image-20250218215951212](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250218215951212.png)

FT （表示可容忍5V）





![image-20250218220444677](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250218220444677.png)



![image-20250218220534032](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250218220534032.png)

![image-20250218220645476](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250218220645476.png)



![image-20250218220809534](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250218220809534.png)





![image-20250218220850802](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250218220850802.png)





![image-20250219090648014](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219090648014.png)

当输出输出数据寄存器（ODR）1 ，IO 由外接电阻决定电压 （开漏输出要接电阻） （高阻态）

![image-20250219090801893](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219090801893.png)  

当输出输出数据寄存器（ODR）0 ，IO 拉到VSS =0   



![](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250218222227773.png)

https://i.imgur.com/c87tJ8O.jpeg  （和上面一样）



![image-20250218222306350](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250218222306350.png)



![image-20250218222053005](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250218222053005.png)



![image-20250218222656004](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250218222656004.png)

##### 2. GPIO寄存器说明

![image-20250219091626810](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219091626810.png)

![image-20250219091758536](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219091758536.png)





![image-20250219091947162](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219091947162.png)



输入数据寄存器与输出数据寄存器ODR一起配合使用  上图中引脚设置为 10 00 （上拉还是下拉 这时候就要配置输出数据寄存器ODR是 0 还是1 ）

![image-20250219092121220](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219092121220.png)

![image-20250219092325810](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219092325810.png)



当输出模式：

![image-20250219092226894](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219092226894.png)



位设置或清楚寄存器

![image-20250219092641307](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219092641307.png)

![image-20250219092702109](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219092702109.png)

设置ODR

![image-20250219092836171](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219092836171.png)

odr  （读数据，分析  写  写0  有影响 ）   bsrr 0不影响  （可以保持不变） 

![image-20250219093232702](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219093232702.png)

与bsrr的高位一样的功能









##### 3. STM32F10xGPIO引脚说明

###### 端口复用

![image-20250219093404128](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219093404128.png)

![image-20250219093419045](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219093419045.png)

###### 端口映射



![image-20250219093504117](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219093504117.png)



![image-20250219093513564](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219093513564.png)

#### 14. 第十四讲跑马灯寄存器版本

寄存器先使能GPIO时钟使能



先清零  在设置   3 -》00 11  输出推完 50HZ



![image-20250219195355094](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219195355094.png)

![image-20250219195524888](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219195524888.png)

非运算![image-20250219195815465](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219195815465.png)   清0 



![image-20250219195915745](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219195915745.png)

#### 第十五讲 跑马灯位操作（操作相关寄存器）

![image-20250219200318680](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219200318680.png)

不要求非常理解（会用就行）

![image-20250219200820803](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219200820803.png)

把某一个位膨胀为一个地址 直接操作地址

![image-20250219200859918](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219200859918.png)

![image-20250219200952526](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219201010650.png)



![image-20250219201133398](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219201133398.png)

![image-20250219201436117](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219201436117.png)

![image-20250219201600036](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219201600036.png)

![image-20250219202418163](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219202418163.png)





#### 16. 第十六讲  蜂鸣器实验   R38电阻   浮空时不响

![image-20250219202609345](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219202609345.png)



![image-20250219202645812](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219202645812.png)

三极管放大电压

![image-20250219202729657](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219202729657.png)

![image-20250219202851481](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219202851481.png)

![image-20250219202859644](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219202859644.png)

![image-20250219203032292](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219203032292.png)

![image-20250219203215203](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219203215203.png)





位操作映射：

![image-20250219203254394](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219203254394.png)

寄存器ODR   /库函数setbits()



#### 17. 第十七讲 按键输入实验  （外部中断）

![image-20250219203559836](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219203559836.png)

 ![image-20250219203815283](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219203815283.png)

![image-20250219204207719](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219204207719.png)![image-20250219204318576](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219204318576.png)



![image-20250219204413295](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219204413295.png)



![image-20250219204723149](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219204723149.png)

第二次调用不会重新初始化（只会一次）



![image-20250219204854645](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219204854645.png)

![image-20250219204933401](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219204933401.png)![image-20250219205103619](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219205103619.png)![image-20250219205406210](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219205406210.png)![image-20250219205511049](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219205511049.png)![image-20250219205531958](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219205531958.png)

#### 18. 第十八讲  C语言的复习 + 寄存器地址名称映射分析



![image-20250219205752693](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219205752693.png)

![image-20250219205844121](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219205844121.png)

![image-20250219205916473](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219205916473.png) 

![image-20250219210329334](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219210329334.png)

![image-20250219210428769](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219210428769.png)

![image-20250219210604540](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219210604540.png)

![image-20250219210638973](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219210638973.png)

![image-20250219210744025](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219210744025.png)

![image-20250219210815738](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219210815738.png)

![image-20250219211033296](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219211033296.png)

![image-20250219211232370](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219211232370.png)

![image-20250219211318119](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219211318119.png)

![image-20250219211608247](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219211608247.png)

![image-20250219211758271](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219211758271.png)

![image-20250219212048887](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219212048887.png)







#### 19.第十九讲  时钟系统

![image-20250219212238220](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219212238220.png)

![image-20250219213003766](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219213003766.png)

![image-20250219213014975](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219213014975.png)

蓝色是时钟源   来自系统时钟

HSI RC  

![image-20250219213116849](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219213116849.png)



HSE RC  外部时钟  晶振

![image-20250219213213214](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219213213214.png)



PLL倍频器  放大（2-  16 ）

![image-20250219213316558](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219213316558.png)

![image-20250219213351415](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219213351415.png)



![image-20250219213423863](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219213423863.png)



RTC时钟来源   低速外部时钟  低俗内部时钟  HSE128分频

![image-20250219213558569](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219213558569.png)





输出内部时钟  PA8   MCO 

![image-20250219213815031](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219213815031.png)





##### 右侧分频

![image-20250219213956932](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219213956932.png)

![image-20250219213940838](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219213940838.png)

![image-20250219214122385](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219214122385.png)

![image-20250219214201376](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219214201376.png) ![image-20250219214405421](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219214405421.png)

![image-20250219214449249](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219214449249.png)

![image-20250219214532692](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219214532692.png)

![image-20250219214733722](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219214733722.png)



![image-20250219214837902](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219214837902.png)

 ![image-20250219215025226](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219215025226.png)

![image-20250219215142736](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219215142736.png)

![image-20250219215219086](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219215219086.png)

![image-20250219215509854](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219215509854.png)







![image-20250219215301663](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219215301663.png)



####  20. 第20讲 SystemInit 时钟系统初始化函数剖析

![image-20250219220511808](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219220511808.png) ![image-20250219220500739](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219220500739.png)

![QQ_1739973926003](C:\Users\86183\AppData\Local\Temp\QQ_1739973926003.png)

![image-20250219220653301](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219220653301.png)



先打开内部高速的8M时钟

![image-20250219221107094](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219221107094.png)

**![image-20250219221121175](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219221121175.png)**



#### 21. 第21讲 systick 定时器（滴答定时器）  delay是用滴答时钟完成的 低功耗-》

![image-20250220193135003](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220193135003.png)

![image-20250220193333428](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220193333428.png)



![image-20250220193751896](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220193751896.png)





![image-20250220193924501](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220193924501.png)



CTRL  控制使能  （0 位-》使能   1位   是否中断   2 clocesouirce 选择时钟源    16  标志位   ）

![image-20250220194121827](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220194121827.png)

![image-20250220194235339](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220194235339.png)





2.load  

![image-20250220194356329](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220194356329.png)



3. value

   ![image-20250220194413288](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220194413288.png)

   ![image-20250220194519312](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220194519312.png)

![image-20250220195032632](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220195032632.png)

![image-20250220195305034](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220195305034.png)

![image-20250220195350643](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220195350643.png)

![image-20250220195625868](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220195625868.png)











![image-20250220195754277](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220195754277.png)

![image-20250220195832966](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220195832966.png)

![image-20250220195938111](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220195938111.png)





#### 22.第22讲  程序调试的方法（不看）

![image-20250220200022035](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220200022035.png)





#### 23. 第二三讲  端口复用和重映射

![image-20250220200444242](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220200444242.png)

1. 什么叫端口复用  ：  最大利用 端口   内置外设

   有很多**内置外设**（串口  ADC  DAC 。。。。。。）

   ![image-20250220200617856](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220200617856.png)

   ![image-20250220200845490](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220200845490.png)

   

2. 配置端口复用

![image-20250220200919263](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220200919263.png)

![image-20250220201003490](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220201003490.png)



![image-20250220201041750](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220201041750.png)



![image-20250220201130627](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220201130627.png)



2.端口重映射  （方便不先）



![image-20250220201222364](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220201222364.png)

![image-20250220201347853](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220201347853.png)

![image-20250220201440893](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220201440893.png)



![image-20250220201546386](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220201546386.png)



![image-20250220201610012](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220201610012.png)



AFIOshizhomgh  dakaide 三种情况

![image-20250220201643281](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220201643281.png)



#### 24. NVIC终端管理  *****************  重要i

![image-20250220201904269](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220201904269.png)

终端优先分组 设置管理  

![image-20250220202136440](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220202136440.png)



F103可屏蔽中断  60个

![image-20250220202237789](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220202237789.png)



##### 1.中断优先级分组  SCB->AIRCR寄存器  分组

![image-20250220202347447](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220202347447.png)



抢占和相应优先级

![image-20250220202447008](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220202447008.png)

![image-20250220202552020](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220202552020.png)

##### 抢占优先级

![image-20250220203154017](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220203154017.png)

![image-20250220203220908](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220203220908.png)

响应优先级只有当抢占优先级相同时才有意义    （高不可以打断低  同时发生时  高相应先发生）

![image-20250220203606939](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220203606939.png)



分组函数

 ![image-20250220203806865](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220203806865.png)

![image-20250220203819367](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220203819367.png)

设置寄存器

![image-20250220203943515](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220203943515.png)

![image-20250220204102942](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220204102942.png)

![image-20250220204140024](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220204140024.png)

![image-20250220204238946](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220204238946.png)



![image-20250220204344320](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220204344320.png)

![image-20250220204451476](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220204451476.png)

 ![image-20250220204709802](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220204709802.png)





例子

![image-20250220204903586](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220204903586.png)

![image-20250220204831448](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220204831448.png)





#### 25.串行通信原理

![image-20250220205416698](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220205416698.png)



通信双方一般有两种通信方式（并行 创行）

![image-20250220205730777](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220205730777.png)

![image-20250220205759753](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220205759753.png)

串行通信

单工

![image-20250220205917200](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220205917200.png)

![image-20250220205938345](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220205938345.png)



 串行通信的通信方式  根据时钟信号来手法数据

![image-20250220210200197](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220210200197.png)

![image-20250220210253034](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220210253034.png)





异步通信的双方一定要约定好波特率（ 同步通信靠时钟） AB 可以根据波特率采取数据



![image-20250220210602323](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220210602323.png) 



USRT可以作为UART来用

![image-20250220210636140](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220210636140.png)

![image-20250220210759241](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220210759241.png)

![image-20250220211144799](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220211144799.png)

 ![image-20250220211327530](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220211327530.png)



奇偶校验  检查数据的准确性

![image-20250220211452776](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220211452776.png)

![image-20250220211512521](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220211512521.png)







![image-20250220211742542](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220211742542.png)

![image-20250220211729860](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220211729860.png)

![image-20250220211826636](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220211826636.png)

![image-20250220212014948](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220212014948.png)![image-20250220212135433](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220212135433.png)

![image-20250220212228184](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220212228184.png)



#### 26. 第26讲  串口体哦那更新寄存器库函数配置  实验



常用寄存器： 状态寄存器   数据寄存器   波特率寄存器

![image-20250220214229423](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220214229423.png)



读和写

![image-20250220214345601](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220214345601.png)



![image-20250220214510241](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220214510241.png)

![image-20250220214532639](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220214532639.png)

![image-20250220214630801](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220214630801.png)

CR1寄存器

![image-20250220214723887](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220214723887.png)

![image-20250220214746150](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220214746150.png)



jie口函数

![image-20250220214819112](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220214819112.png)

![image-20250220214914087](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220214914087.png)

![image-20250220215005323](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220215005323.png)

![image-20250220215211479](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220215211479.png)



代码





![image-20250220220415697](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220220415697.png)



![image-20250220220446782](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220220446782.png)

![image-20250220220726160](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220220726160.png)





#### 27.第27讲  串口通信实验讲解

![image-20250220221059289](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220221059289.png)

#### 28. 第二十八讲  外部中断

![image-20250221202129023](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250221202129023.png)



![image-20250221203253100](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250221203253100.png)

![image-20250221203544553](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250221203544553.png)

![image-20250221203950488](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250221203950488.png)



中断向量（有一些是单独的  有一些是gongying的）

![image-20250221204120061](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250221204120061.png)

![image-20250221204242087](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250221204242087.png)

![image-20250221204356829](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250221204356829.png)





AFIO一定要开启

![image-20250221204457508](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250221204457508.png)





![image-20250221204552939](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250221204552939.png)



![image-20250221205609285](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250221205609285.png)

![image-20250221205641737](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250221205641737.png)

#### 29. 独立看门狗

![image-20250221205948400](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250221205948400.png)



![image-20250221210137963](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250221210137963.png)



![image-20250221210152485](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250221210152485.png)

杜库里看门狗  窗口看门狗

![image-20250221210252058](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250221210252058.png)

![image-20250221210822022](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250221210822022.png)

![image-20250221210914453](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250221210914453.png)





![image-20250221211016396](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250221211016396.png)



![image-20250221211046504](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250221211046504.png)

![image-20250221211110597](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250221211110597.png)

![image-20250221211201096](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250221211201096.png)



![image-20250221211249637](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250221211249637.png)



![image-20250221211325399](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250221211325399.png)



![image-20250221211928009](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250221211928009.png)

#### 30.第三十讲窗口看门狗



#### 31. 通用定时器基本原理

![image-20250221212153981](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250221212153981.png)



![image-20250221212240197](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250221212240197.png)



![image-20250221212907878](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250221212907878.png)





![image-20250221213027839](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250221213027839.png)

![image-20250221213224914](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250221213224914.png)

![image-20250221213413299](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250221213413299.png)

![image-20250221215407077](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250221215407077.png)

![image-20250221220048095](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250221220048095.png)



![image-20250221220129023](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250221220129023.png)

![image-20250221220316413](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250221220316413.png)

![image-20250221220653699](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250221220653699.png)



![image-20250221221016245](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250221221016245.png)

![image-20250221221134360](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250221221134360.png)





