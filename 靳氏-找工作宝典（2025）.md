# 靳氏-找工作宝典（2025）
## 一.工作岗位基础知识了解

### c++嵌入式岗位

#### 1.  c++嵌入式岗位分为哪几种，分别负责什么技术

#####  **1. 嵌入式软件开发工程师**

- **职责**：
  - 开发嵌入式系统上的应用程序（如通信协议、控制逻辑、数据处理等）。
  - 基于RTOS（实时操作系统）或裸机开发，优化代码性能和内存占用。
  - 与硬件团队协作调试，解决软硬件兼容性问题。
- **核心技术**：
  - C++（面向对象设计、资源管理、C++11/14特性）。
  - RTOS（FreeRTOS、RT-Thread、Zephyr等）。
  - [通信协议（UART/SPI/I2C、CAN、TCP/IP、MQTT等）。](https://www.nowcoder.com/discuss/718485020645552128?sourceSSR=users) 

##### 2.  嵌入式驱动开发工程师

- **职责**：
  - 编写硬件外设驱动（如传感器、显示屏、无线模块等）。
  - 调试底层硬件接口（GPIO、DMA、中断控制器）。
  - 优化驱动性能（减少延迟、提高吞吐量）。
- **核心技术**：
  - C/C++（贴近硬件的代码实现）。
  - 硬件知识（ARM Cortex-M/A系列、寄存器操作、时钟树配置）。
  - 调试工具（示波器、逻辑分析仪、JTAG/SWD）。

##### 3. 嵌入式系统架构师

- **职责**：
  - 设计嵌入式系统整体架构（硬件选型、软件分层、模块划分）。
  - 制定实时性、功耗、安全性等系统级指标。
  - 解决跨模块的技术难题（如多线程同步、内存泄漏排查）。
- **核心技术**：
  - 系统设计能力（模块化、解耦、设计模式）。
  - 多任务调度（优先级反转、死锁预防）。
  - 性能分析工具（Tracealyzer、SystemView）。

##### 4. 物联网（IOT）嵌入式开发

- **职责**：

  - 开发物联网设备端固件（如智能家居、工业传感器）。
  - 实现低功耗设计（休眠唤醒、电源管理）。
  - 对接云平台（AWS IoT、阿里云IoT）。

- **核心技术**：

  - 低功耗技术（STM32的低功耗模式、动态电压调节）。

  - 无线协议（BLE、LoRa、NB-IoT）。

  - 安全机制（TLS/DTLS、加密算法）。

    

##### 5. 汽车电子嵌入式开发

- **职责**：
  - 开发车规级ECU（电子控制单元）软件（如ADAS、车载娱乐系统）。
  - 遵循AUTOSAR架构，实现功能安全（ISO 26262）。
  - 支持CAN/LIN总线通信。
- **核心技术**：
  - AUTOSAR（BSW/SW-C分层开发）。
  - 功能安全（ASIL等级、FMEA分析）。
  - 汽车通信协议（CAN FD、DoIP、SOME/IP）。



#### 2. 研二暑假实习需要具备的技能














## 二. 真心好网站

### 1. 牛客

1[.牛客：sagima (实验室学长) 双九 最后去了 中国移动](https://www.nowcoder.com/discuss/716949192207237120?sourceSSR=users) 

### 2. 代码随想录

[代码随想录的题目](https://programmercarl.com/0704.%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE)

### 3. 二刷代码随想录，整理出自己的一套做题思路

#### 1. 数组

数组能考的题型：a=[1,2,3,4,5,6] 

查找（二分查找）

插入

删除

移动

前缀和、区间和、滑动窗口（说的好像是一件事）



##### 1. 数组理论基础

数组的存储方式：在c++中连续的一段内存地址；（查询数组内元素的时间复杂度是 0（1）插入删除元素的时间复杂度是0（n））

![image-20250212154746740](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250212154746740.png)

##### 2. [二分查找（二分查找有两种开区间和闭区间](https://programmercarl.com/0704.%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html)）  时间复杂度是  0（logn）

过了  但是注意开区间闭区间    right=mid-1;left =mid+1;  （是否加1的问题）

###### 1. [搜索插入位置（为什么返回值一定是right+1）](https://programmercarl.com/0035.%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE.html)

给定一个排序阵列和一个目标值，在阵列中找到目标值，并返回其索引。如果目标值不存在于阵列中，则返回它将被按顺序插入的位置。

![image-20250212163739835](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250212163739835.png)

###### 2. [在排序数组中查找元素的第一个和最后一个位置](https://programmercarl.com/0034.%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE.html)（通过二分查找法确实可以找到中间的位置，但怎么找到左右边界呢）（中等难度的题型） （两个二分查找单独查找）

给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。

如果数组中不存在目标值 target，返回 [-1, -1]。

进阶：你可以设计并实现时间复杂度为 $O(\log n)$ 的算法解决此问题吗？

###### 3. x的平方根（二分查找  平方从  注意数组范围）

给你一个非负整数 `x` ，计算并返回 `x` 的 **算术平方根** 。

由于返回类型是整数，结果只保留 **整数部分** ，小数部分将被 **舍去 。**

**注意：**不允许使用任何内置指数函数和算符，例如 `pow(x, 0.5)` 或者 `x ** 0.5` 。

```c++
class Solution {
public:
    int mySqrt(int x) {
        int left=0;
        int right=x;

        while(left<=right)
        {
            long long  mid=(left+right)/2; // long long 数组范围
            if(mid*mid==x) return mid;
            else if(mid*mid>x) right=mid-1;
            else  left=mid+1;
        }
        return right;
    }
};
```

###### 4. 有效的完全平方数（二分查找 简单的很）

给你一个正整数 `num` 。如果 `num` 是一个完全平方数，则返回 `true` ，否则返回 `false` 。

**完全平方数** 是一个可以写成某个整数的平方的整数。换句话说，它可以写成某个整数和自身的乘积。

不能使用任何内置的库函数，如 `sqrt` 。

##### 3. [移除元素](https://programmercarl.com/0027.%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE)（双指针法  快指针  慢指针）数组的移动和删除元素都用到双指针法。

给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。

不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并**原地**修改输入数组。

元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。

示例 1: 给定 nums = [3,2,2,3], val = 3, 函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。 你不需要考虑数组中超出新长度后面的元素。

示例 2: 给定 nums = [0,1,2,2,3,0,4,2], val = 2, 函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。

**你不需要考虑数组中超出新长度后面的元素。**

```c++
class Solution {
public:   //快慢指针法
    int removeElement(vector<int>& nums, int val) {
            int slow=0;
            for(int fast=0;fast<=nums.size()-1;fast++)
            {
                if(nums[fast]!=val)
                {
                    nums[slow]=nums[fast];
                    slow++;
                }
            }
            return slow;
    }
};
```

###### 1. 删除排序数组中的重复项( * )

给你一个 **非严格递增排列** 的数组 `nums` ，请你**[ 原地](http://baike.baidu.com/item/原地算法)** 删除重复出现的元素，使每个元素 **只出现一次** ，返回删除后数组的新长度。元素的 **相对顺序** 应该保持 **一致** 。然后返回 `nums` 中唯一元素的个数。

```c++
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        // if(nums.size()==1) return 1;

        int slow=0;
        for(int fast=1;fast<=nums.size()-1;fast++)
        {
            if(nums[slow]!=nums[fast])
            {
                    nums[++slow]=nums[fast];
            }
        }
        return slow+1;
    }
};
```

###### 2 移动零 （交换 * ）

给定一个数组 `nums`，编写一个函数将所有 `0` 移动到数组的末尾，同时保持非零元素的相对顺序。

```c++
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        int slow=0;
        for(int fast=0;fast<nums.size();fast++)
        {
            if(nums[fast])
            {
                swap(nums[slow],nums[fast]);
                slow++;
            }
           
        }

    }
};
```

###### 3  比较含退格的字符串

给定 `s` 和 `t` 两个字符串，当它们分别被输入到空白的文本编辑器后，如果两者相等，返回 `true` 。`#` 代表退格字符。

**注意：**如果对空文本输入退格字符，文本继续为空。

```c++
class Solution {
public:
    bool backspaceCompare(string s, string t) {
        
        string res=restring(s);
        string ret=restring(t);
        return res==ret;
    }
    
    string restring(string & str)
    {
        int slow=0;
        for(int  fast=0;fast<str.size();fast++)
        {
            if(str[fast]!='#')
            {
                str[slow]=str[fast];
                slow++;
            }
            else if(slow>0) slow--; //注意越界
        }
        return str.substr(0,slow);  //注意c++没有切片

    }
};
```

##### 4.  有序数组的平方 ***(既然是有序数组 那可以用双指针法)

给你一个按 **非递减顺序** 排序的整数数组 `nums`，返回 **每个数字的平方** 组成的新数组，要求也按 **非递减顺序** 排序。

- 输入：nums = [-4,-1,0,3,10]
- 输出：[0,1,9,16,100]
- 解释：平方后，数组变为 [16,1,0,9,100]，排序后，数组变为 [0,1,9,16,100]

示例 2：

- 输入：nums = [-7,-3,2,3,11]
- 输出：[4,9,9,49,121]

```c++
class Solution {
public:
    vector<int> sortedSquares(vector<int>& nums) {
        for(int i=0;i<nums.size();i++)
        {
            nums[i]*=nums[i];
        }
        sort(nums.begin(),nums.end());
        return nums;
    }
};
```

这个时间复杂度是 O(n + nlogn)， 可以说是O(nlogn)的时间复杂度，但为了和下面双指针法算法时间复杂度有鲜明对比，我记为 O(n + nlog n)。



双指针法；

```c++

        int left=0;
        int right=nums.size()-1;
        vector<int> res(nums.size(),0);
        for(int n=nums.size()-1;n>=0;n--)
        {
            if(nums[right]*nums[right]>=nums[left]*nums[left])
            {
                res[n]=nums[right]*nums[right];
                right--;
            } 
            else 
            {
                res[n]=nums[left]*nums[left];
                left++;
            }
        }
        return res;
    }
```

##### 5.长度最小的子数组*

给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的 连续 子数组，并返回其长度。如果不存在符合条件的子数组，返回 0。

示例：

- 输入：s = 7, nums = [2,3,1,2,4,3]
- 输出：2
- 解释：子数组 [4,3] 是该条件下的长度最小的子数组。

提示：

- 1 <= target <= 10^9
- 1 <= nums.length <= 10^5
- 1 <= nums[i] <= 10^5

```c++
class Solution {
public:
    int minSubArrayLen(int target, vector<int>& nums) {
        if(nums.empty()) return 0;
        int slow=0;
        int sum=0;
        int res=INT_MAX;
        for(int fast =0 ; fast<nums.size();fast++)
        {
            sum+=nums[fast];
            while(sum>=target)
            {
                res=min(res,fast-slow+1);
                sum-=nums[slow];
                slow++;
            }
        }
      
        return res==INT_MAX?0:res;
    }
};
```

###### 1.水果成蓝（中等）

你正在探访一家农场，农场从左到右种植了一排果树。这些树用一个整数数组 `fruits` 表示，其中 `fruits[i]` 是第 `i` 棵树上的水果 **种类** 。

你想要尽可能多地收集水果。然而，农场的主人设定了一些严格的规矩，你必须按照要求采摘水果：

- 你只有 **两个** 篮子，并且每个篮子只能装 **单一类型** 的水果。每个篮子能够装的水果总量没有限制。
- 你可以选择任意一棵树开始采摘，你必须从 **每棵** 树（包括开始采摘的树）上 **恰好摘一个水果** 。采摘的水果应当符合篮子中的水果类型。每采摘一次，你将会向右移动到下一棵树，并继续采摘。
- 一旦你走到某棵树前，但水果不符合篮子的水果类型，那么就必须停止采摘。

给你一个整数数组 `fruits` ，返回你可以收集的水果的 **最大** 数目

```c++
class Solution {
public:
    int totalFruit(vector<int>& fruits) {
        unordered_map<int, int> res;
        int result = 0;  // 初始化为 0，而不是 INT_MIN
        for (int left = 0, right = 0; right < fruits.size(); right++) {
            res[fruits[right]]++;  // 右指针向右扩展窗口
            // 如果水果种类超过2，左指针向右移动，直到种类数不超过2
            while (res.size() > 2) {
                res[fruits[left]]--;
                if (res[fruits[left]] == 0) {
                    res.erase(fruits[left]);
                }
                left++;
            }
            // 计算当前窗口大小并更新结果
            result = max(result, right - left + 1);
        }
        return result;
    }
};

```



###### 2.最小覆盖字串（困难）（哈希表加滑动窗口******）

给你一个字符串 `s` 、一个字符串 `t` 。返回 `s` 中涵盖 `t` 所有字符的最小子串。如果 `s` 中不存在涵盖 `t` 所有字符的子串，则返回空字符串 `""` 。

 

**注意：**

- 对于 `t` 中重复字符，我们寻找的子字符串中该字符数量必须不少于 `t` 中该字符数量。
- 如果 `s` 中存在这样的子串，我们保证它是唯一的答案。



##### 6.螺旋矩阵（中等）

给定一个正整数 n，生成一个包含 1 到 n^2 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。

示例:

输入: 3 输出: [ [ 1, 2, 3 ], [ 8, 9, 4 ], [ 7, 6, 5 ] ]

```c++
class Solution {
public:
    vector<vector<int>> generateMatrix(int n) {
        int t=0;
        int b=n-1;
        int l=0;
        int r=n-1;
        vector<vector<int>> res(n,vector<int>(n,0)); //初始化
        int num=1;

        while(num<=n*n)
        {
            for(int i=l;i<=r;i++)
            {
                res[t][i]=num++;
            }
            t++;
            for(int i=t;i<=b;i++)
            {
                res[i][r]=num++;
            }
            r--;
            for(int i=r;i>=l;i--)
            {
                res[b][i]=num++;
            }
            b--;

            for(int i=b;i>=t;i--)
            {
                res[i][l]=num++;
            }
            l++;
        }
        return res;
    }
};
```

###### 1.螺旋矩阵

给你一个 `m` 行 `n` 列的矩阵 `matrix` ，请按照 **顺时针螺旋顺序** ，返回矩阵中的所有元素。

 

```c++
class Solution {
public:
    vector<int> spiralOrder(vector<vector<int>>& matrix) {
        int t=0;
        int l=0;
        int b=matrix.size()-1;
        int r=matrix[0].size()-1;
        vector<int> res(matrix.size()*matrix[0].size(),0);
        int index=0;
        while(index<(matrix.size()*matrix[0].size()))
        {
            for(int i=l;i<=r;i++)
            {
                res[index++]=matrix[t][i];
            }
            t++;

            for(int i=t;i<=b;i++)
            {
                res[index++]=matrix[i][r];
            }
            r--;

            //在更新边界时，程序可能会重复访问已经处理过的元素，尤其是在矩阵维度较小（如行数或列数为 1）时。为了避免这种情况，您需要在每个循环时检查是否有剩余的行或列进行处理。

            
            if(t<=b)  // 如果仍然有行剩余
            {
                for(int i=r;i>=l;i--)
                {
                    res[index++]=matrix[b][i];
                }
                b--;                
            }
            if(l<=r)   // 如果仍然有列剩余
            {
                for(int i=b;i>=t;i--)
                {
                    res[index++]=matrix[i][l];
                }
                l++;          

            }

        }
        return res;
    }
};
```



###### 2.螺旋遍历二维数组 //同上

给定一个二维数组 `array`，请返回「**螺旋遍历**」该数组的结果。

**螺旋遍历**：从左上角开始，按照 **向右**、**向下**、**向左**、**向上** 的顺序 **依次** 提取元素，然后再进入内部一层重复相同的步骤，直到提取完所有元素。

 ##### 7.区间和

给定一个整数数组 Array，请计算该数组在每个指定区间内元素的总和。

输入描述

第一行输入为整数数组 Array 的长度 n，接下来 n 行，每行一个整数，表示数组的元素。随后的输入为需要计算总和的区间，直至文件结束。

输出描述

输出每个指定区间内元素的总和。

输入示例

```c++
#include<iostream>
#include<vector>
using namespace std;

int main()
{
    int n=0;
    cin>>n;
    vector<int> num(n,0);
    vector<int> sum(n,0);
    int add=0;
    for(int i=0;i<n;i++)
    {
        cin>>num[i];
        add+=num[i];
        sum[i]=add;
        // cout<<sum[i];
    }
    int l,r;
    while(cin>>l>>r)   //错误
    {
            
            if(l!=0)    cout<<sum[r]-sum[l-1]<<endl;
            else cout<<sum[r]<<endl;
    }  
        
    }

```





##### 8.开发商购买土地(单独求出行和和列和)（** 没看完）

【题目描述】

在一个城市区域内，被划分成了n * m个连续的区块，每个区块都拥有不同的权值，代表着其土地价值。目前，有两家开发公司，A 公司和 B 公司，希望购买这个城市区域的土地。

现在，需要将这个城市区域的所有区块分配给 A 公司和 B 公司。

然而，由于城市规划的限制，只允许将区域按横向或纵向划分成两个子区域，而且每个子区域都必须包含一个或多个区块。

为了确保公平竞争，你需要找到一种分配方式，使得 A 公司和 B 公司各自的子区域内的土地总价值之差最小。

注意：区块不可再分。

【输入描述】

第一行输入两个正整数，代表 n 和 m。

接下来的 n 行，每行输出 m 个正整数。

输出描述

请输出一个整数，代表两个子区域内土地总价值之间的最小差距。

【输入示例】

3 3 1 2 3 2 1 3 1 2 3

【输出示例】

0

【提示信息】

如果将区域按照如下方式划分：

1 2 | 3 2 1 | 3 1 2 | 3

两个子区域内土地总价值之间的最小差距可以达到 0。

【数据范围】：

- 1 <= n, m <= 100；
- n 和 m 不同时为 1。



####  2   链表

（移除链表元素、设计链表、反转链表、两两交换链表中节点、删除链表倒数N个节点、链表香蕉、环形链表、）

链表最好设置一个虚拟节点指向头节点操作

##### 1.链表理论基础



![image-20250214083938791](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250214083938791.png)

![image-20250214084012858](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250214084012858.png)

![image-20250214084038739](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250214084038739.png)





![image-20250213191232339](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250213191232339.png)

![image-20250213191253157](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250213191253157.png)

######  链表的存储方式（非连续）

链表在内存中的存储非连续  散乱分布，分配机制取决于内存管理机制

![image-20250213191550384](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250213191550384.png)

###### 链表的定义（******）

```c++
struct ListNode{
int val; //节点上存储的元素
ListNode *next;//指向下一个节点的指针
ListNode(int x):val(x),next(Null){}//节点的构造函数
};

```

![image-20250213192115567](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250213192115567.png)



```c++
//通过自定义的构造函数给ListNode节点赋值
ListNode *next= new ListNode(5);
//使用默认的构造函数
ListNode *next=new ListNode();
next->val=5;
//所以如果不定义构造函数使用默认构造函数的话，在初始化的时候就不能直接给变量赋值！

```

###### 链表的操作（查找的时间复杂度为0（n）添加等操作位o(1)）

删除  新增节点  替换  

![image-20250213193705224](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250213193705224.png)

![链表-链表与数据性能对比](https://code-thinking-1253855093.file.myqcloud.com/pics/20200806195200276.png)

数组在定义的时候，长度就是固定的，如果想改动数组的长度，就需要重新定义一个新的数组。

链表的长度可以是不固定的，并且可以动态增删， 适合数据量不固定，频繁增删，较少查询的场景。

相信大家已经对链表足够的了解，后面我会讲解关于链表的高频面试题目，我们下期见！



##### 2.移除链表元素

```c++
 //定义单链表
 struct ListNode{
    int val;
    ListNode *next;
    ListNode(int x):val(x),next(nullptr){}
    ListNode():val(0),next(nullptr){}
    ListNode(int x,ListNode *next):val(x),next(next){}
 };
```

![image-20250213202345007](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250213202345007.png)

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */

//  //定义单链表
//  struct ListNode{
//     int val;
//     ListNode *next;
//     ListNode(int x):val(x),next(nullptr){}
//     ListNode():val(0),next(nullptr){}
//     ListNode(int x,ListNode *next):val(x),next(next){}
//  };

class Solution {
public:
    ListNode* removeElements(ListNode* head, int val) {
        ListNode * dummyHead= new ListNode(0);  //虚拟头节点
        dummyHead->next=head;
            ListNode * cur=dummyHead;
        while(cur->next!=nullptr)
        {
            if(cur->next->val==val)
            {
                ListNode * temp=cur->next;
                cur->next=temp->next;
                delete(temp);
            }
            else{
                cur=cur->next;
            }
        }
        return dummyHead->next;
    }
};
```

##### 3.设计链表

题意：

在链表类中实现这些功能：

- get(index)：获取链表中第 index 个节点的值。如果索引无效，则返回-1。
- addAtHead(val)：在链表的第一个元素之前添加一个值为 val 的节点。插入后，新节点将成为链表的第一个节点。
- addAtTail(val)：将值为 val 的节点追加到链表的最后一个元素。
- addAtIndex(index,val)：在链表中的第 index 个节点之前添加值为 val 的节点。如果 index 等于链表的长度，则该节点将附加到链表的末尾。如果 index 大于链表长度，则不会插入节点。如果index小于0，则在头部插入节点。
- deleteAtIndex(index)：如果索引 index 有效，则删除链表中的第 index 个节点。

```c++
class MyLinkedList {
public:
    // 定义链表节点结构体
    struct LinkedNode {
        int val;
        LinkedNode* next;
        LinkedNode(int val):val(val), next(nullptr){}
    };

    // 初始化链表
    MyLinkedList() {
        _dummyHead = new LinkedNode(0); // 这里定义的头结点 是一个虚拟头结点，而不是真正的链表头结点
        _size = 0;
    }

    // 获取到第index个节点数值，如果index是非法数值直接返回-1， 注意index是从0开始的，第0个节点就是头结点
    int get(int index) {
        if (index > (_size - 1) || index < 0) {
            return -1;
        }
        LinkedNode* cur = _dummyHead->next;
        while(index--){ // 如果--index 就会陷入死循环
            cur = cur->next;
        }
        return cur->val;
    }

    // 在链表最前面插入一个节点，插入完成后，新插入的节点为链表的新的头结点
    void addAtHead(int val) {
        LinkedNode* newNode = new LinkedNode(val);
        newNode->next = _dummyHead->next;
        _dummyHead->next = newNode;
        _size++;
    }

    // 在链表最后面添加一个节点
    void addAtTail(int val) {
        LinkedNode* newNode = new LinkedNode(val);
        LinkedNode* cur = _dummyHead;
        while(cur->next != nullptr){
            cur = cur->next;
        }
        cur->next = newNode;
        _size++;
    }

    // 在第index个节点之前插入一个新节点，例如index为0，那么新插入的节点为链表的新头节点。
    // 如果index 等于链表的长度，则说明是新插入的节点为链表的尾结点
    // 如果index大于链表的长度，则返回空
    // 如果index小于0，则在头部插入节点
    void addAtIndex(int index, int val) {

        if(index > _size) return;
        if(index < 0) index = 0;        
        LinkedNode* newNode = new LinkedNode(val);
        LinkedNode* cur = _dummyHead;
        while(index--) {
            cur = cur->next;
        }
        newNode->next = cur->next;
        cur->next = newNode;
        _size++;
    }

    // 删除第index个节点，如果index 大于等于链表的长度，直接return，注意index是从0开始的
    void deleteAtIndex(int index) {
        if (index >= _size || index < 0) {
            return;
        }
        LinkedNode* cur = _dummyHead;
        while(index--) {
            cur = cur ->next;
        }
        LinkedNode* tmp = cur->next;
        cur->next = cur->next->next;
        delete tmp;
        //delete命令指示释放了tmp指针原本所指的那部分内存，
        //被delete后的指针tmp的值（地址）并非就是NULL，而是随机值。也就是被delete后，
        //如果不再加上一句tmp=nullptr,tmp会成为乱指的野指针
        //如果之后的程序不小心使用了tmp，会指向难以预想的内存空间
        tmp=nullptr;
        _size--;
    }

    // 打印链表
    void printLinkedList() {
        LinkedNode* cur = _dummyHead;
        while (cur->next != nullptr) {
            cout << cur->next->val << " ";
            cur = cur->next;
        }
        cout << endl;
    }
private:
    int _size;
    LinkedNode* _dummyHead;

};
```

##### 4. 反转链表



题意：反转一个单链表。

示例: 输入: 1->2->3->4->5->NULL 输出: 5->4->3->2->1->NULL

![image-20250213212656819](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250213212656819.png)

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        ListNode *cur=NULL;
        ListNode *pre=head;
        while(pre!=NULL)
        {
            ListNode *temp=pre->next;
            pre->next=cur;
            cur=pre;
            pre=temp;

        }
        return cur;
    }
};
```

##### 5. 两两交换链表中的节点

给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。

你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。

![24.两两交换链表中的节点-题意](https://code-thinking.cdn.bcebos.com/pics/24.%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9-%E9%A2%98%E6%84%8F.jpg)

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
        ListNode *dummyNode= new ListNode(0);
        dummyNode->next=head;
        ListNode *cur=dummyNode;
        while(cur->next!=nullptr && cur->next->next!=nullptr)
        {
            ListNode *node1=cur->next;
            ListNode *node2=node1->next;
            ListNode *node3=node2->next;
            cur->next=node2;
            node2->next=node1;
            node1->next=node3;
            cur=node1;

        }
        return dummyNode->next;

    }
};
```

##### 6. 删除链表的倒数第N个节点（双指针的经典应用）

给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。

进阶：你能尝试使用一趟扫描实现吗？  （只要想到 fast 和slow 之间的距离是n就行  fast到迷哦卫视删除slow）

![image-20250213214603674](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250213214603674.png)

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        ListNode * dummyHead= new ListNode(0);
        dummyHead->next=head;
        ListNode *fast=dummyHead;
        ListNode *slow=dummyHead;
        for(int i=0;i<n;i++) //多走一步  n+1
        {
            fast=fast->next;
        }
        while(fast->next!=nullptr)
        {
            fast=fast->next;
            slow=slow->next;
        }
        ListNode *temp=slow->next;
        slow->next=temp->next;
        delete temp;
        return dummyHead->next; //代码本身是正确的，但是返回的应该是 dummyHead->next 而不是 head。因为如果删除的是链表的第一个节点，head 会发生变化，返回 dummyHead->next 才能确保返回正确的链表头。
    }
};

```

##### 7.链表相交(双指针 ** )

```c++

        //双指针法
        if(headA==NULL || headB==NULL)
        {
            return NULL;
        }
        ListNode *pA=headA;
        ListNode *pB=headB;
        while(pA!=pB)
        {
            pA=pA==NULL?headB:pA->next;
            pB=pB==NULL?headA:pB->next;
        }
        return pA;
```



给你两个单链表的头节点 headA 和 headB ，请你查找并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。

图标两个链表在节点c1开始相交：

![img](https://code-thinking-1253855093.file.myqcloud.com/pics/20211219221657.png)

题目数据保证整个链式结构中不存在环。

注意，函数返回结果后，链表必须保持其原始结构。

示例1：

![img](https://code-thinking-1253855093.file.myqcloud.com/pics/20211219221723.png)

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public://哈希表  地址相同
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        unordered_map<ListNode* ,int> list1;

        ListNode *dummyHead1=new ListNode(0);
        dummyHead1->next=headA;
        ListNode *cur=dummyHead1;
        while(cur->next!=NULL)
        {
            list1[cur->next]++;
            cur=cur->next;
        }

        ListNode *dummyHead2=new ListNode(0);
        dummyHead2->next=headB;
        ListNode *cur2=dummyHead2;
        while(cur2->next!=NULL)
        {
            if(list1.find(cur2->next)!=list1.end())
            {
                return cur2->next;
            }
            cur2 = cur2->next;  // 移动cur2
        }
        return NULL;
    }
};
```

##### 8.环形链表II(哈希表   秒了)

题意：给定一个链表，返回链表开始入环的第一个节点。如果链表无环，则返回null。

为了表示给定链表中的环，用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 pos 为 -1，则如果该链表中没有环。

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:  //哈希表集地址
    ListNode *detectCycle(ListNode *head) {
        unordered_map<ListNode*,int> cnt;
        ListNode* dummyHead=new ListNode(0);
        dummyHead->next=head;
        ListNode* cur=dummyHead;
        while(cur->next!=NULL)
        {
            if(cnt.find(cur->next)!=cnt.end()) return cur->next;
            cnt[cur->next]++;
            cur=cur->next;

        }
        return NULL;
    }
};
```

#### 3. 哈希表

##### 1. [哈希表理论基础](https://programmercarl.com/%E5%93%88%E5%B8%8C%E8%A1%A8%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0)

###### 常见的三种哈希结构

当我们想使用哈希法来解决问题的时候，我们一般会选择如下三种数据结构。

- 数组
- set （集合）
- map(映射)

这里数组就没啥可说的了，我们来看一下set。

​     ![image-20250214102148824](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250214102148824.png)

![image-20250214102339555](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250214102339555.png)



总结一下，**当我们遇到了要快速判断一个元素是否出现集合里的时候，就要考虑哈希法**。

但是哈希法也是**牺牲了空间换取了时间**，因为我们要使用额外的数组，set或者是map来存放数据，才能实现快速的查找。

如果在做面试题目的时候遇到需要判断一个元素是否出现过的场景也应该第一时间想到哈希法

##### 2. 有效的字母异位词*（注意当开两个字符串长度不相等时）

给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。

示例 1: 输入: s = "anagram", t = "nagaram" 输出: true

示例 2: 输入: s = "rat", t = "car" 输出: false

**说明:** 你可以假设字符串只包含小写字母

```c++
class Solution {
public:
    bool isAnagram(string s, string t) {
        //长度不相等时
        if(s.size()!=t.size()) return false;
        unordered_map<char,int> map_s;
        for(char c:s)
        {
            map_s[c]++;
        }
        for(char c:t)
        {
            if(map_s.find(c)!=map_s.end())
            {
                 map_s[c]--;
                if(map_s[c]==0)
                { map_s.erase(c);}
            }
            else return false;

        }
        return true;


    }
};
```

###### 1. 赎金信（和上一题代码一样）

![image-20250214105227120](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250214105227120.png)

###### 2. 字母异位词分组

![image-20250214105528916](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250214105528916.png)

```c++
class Solution {
public:
    vector<vector<string>> groupAnagrams(vector<string>& strs) {
        
        //给每个子字符串排序，直接判断相等
        vector<vector<string>> res;
        // vector<string> temp;
        unordered_map<string,vector<string>> set_res;
        for(int i=0;i<strs.size();i++)
        {
            string temp=strs[i];
            sort(temp.begin(),temp.end());
            set_res[temp].push_back(strs[i]);
        }
        //遍历map
        while(set_res.size()!=0)
        {
            res.push_back(set_res[set_res.begin()->first]);
            set_res.erase(set_res.begin()->first);
        }
        return res;



    }
};
```



###### 3. 找到字符串中所有字母异位词

![image-20250214172443780](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250214172443780.png)

```c++
class Solution {
public:
    vector<int> findAnagrams(string s, string p) {
        //滑动窗口法    p.size对比
        int s_size=s.size();
        int p_size=p.size();
        vector<int> s_map(26,0);//长度26  初始次数为0
        vector<int> p_map(26,0);
        vector<int> res;
        for(int i=0;i<p_size;i++)
        {
            p_map[p[i]-'a']++;
        }
        int left=0;
        // int right=p_size()-1;
        for(int right=0;right<=s_size-1;right++)
        {
            s_map[s[right]-'a']++;
            if(right-left+1>=p_size)
            {
                if(s_map==p_map)
                {
                    res.push_back(left);
                }
                
                s_map[s[left]-'a']--;
                left++;
            }
        }
        return res;


    }

};
```

##### 3.两数组的交集

![image-20250218094221491](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250218094221491.png)

```c++
class Solution {
public:
    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {
        unordered_map<int,int> n1;
        for(int i=0;i<nums1.size();i++)
        {
                n1[nums1[i]]++;
        }

        vector<int> res;
        for(int i=0;i<nums2.size();i++)
        {
            if(n1.find(nums2[i])!=n1.end())
            {
                res.push_back(nums2[i]);
                n1[nums2[i]]=0;
                 n1.erase(nums2[i]);
            }
        }
        return res;
    }
};
```

###### 数组交集2

![image-20250218094300426](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250218094300426.png)

```c++
// class Solution {
// public:
//     vector<int> intersect(vector<int>& nums1, vector<int>& nums2) {
        
//     }
// };


class Solution {
public:
    vector<int> intersect(vector<int>& nums1, vector<int>& nums2) {
        unordered_map<int,int> n1;
        for(int i=0;i<nums1.size();i++)
        {
                n1[nums1[i]]++;
        }

        vector<int> res;
        for(int i=0;i<nums2.size();i++)
        {
            if(n1.find(nums2[i])!=n1.end())
            {
                res.push_back(nums2[i]);
                n1[nums2[i]]--;
                if(n1[nums2[i]]==0) n1.erase(nums2[i]);
            }
        }
        return res;
    }
};
```

##### 4. 快乐数

![image-20250218094331293](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250218094331293.png)

```c++
class Solution {
public:
    bool isHappy(int n) {
        unordered_map<int,int> res;

        while(n!=1)
        {
            int cnt=fun(n);
            if(cnt==n) return true;
            if(res.find(cnt)!=res.end())
            {
                return false;
            }
            res[cnt]++;
            n=cnt;
        }
        return true;

    }

    long long fun(int num)
    {   int temp=0;
    int last=0;
        while( num>0)
        {
            last=num%10;//取出最后一位
            num/=10;//去掉最后一位
            temp+=last*last;
        }
        return temp;
    }
};
```

##### 5.两数之和

![image-20250218094416728](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250218094416728.png)

![image-20250218094429678](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250218094429678.png)

```c++
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        vector<int> res;
        unordered_map<int,int> cnt;
        for(int i=0;i<nums.size();i++)
        {
            int temp=target-nums[i];
            auto it=cnt.find(temp);
            if(it!=cnt.end())
            {
                return {it->second,i};
            }
            cnt[nums[i]]=i;
        }
        return {0,0};
    }
};
```

##### 6. 四数相加

![image-20250218094525655](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250218094525655.png)



```c++
class Solution {
public:
    int fourSumCount(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3, vector<int>& nums4) {
        //两两组合 
        unordered_map<int,int> compos1;
        int count=0;
        // unoedered_map<int,int> compos2;
        for(int i=0;i<nums1.size();i++)
        {
            for(int j=0;j<nums2.size();j++)
            {
                compos1[nums1[i]+nums2[j]]++;
            }
        }
        for(int i=0;i<nums3.size();i++)
        {
            for(int j=0;j<nums4.size();j++)
            {
                int target=-nums3[i]-nums4[j];
               if(compos1.find(target)!=compos1.end())
               {
                    count+=compos1[target];
   
               }
            }
        }
        return count;

    }
};
```



##### 7. 赎金信

![image-20250218100330374](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250218100330374.png)

```

```



##### 8. 三数之和 （一个数组里面k数和 = 0 ）

（三指针）

![image-20250218100445749](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250218100445749.png)

```c++
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        vector<vector<int>> res;
        sort(nums.begin(), nums.end());  // 排序

        for (int i = 0; i < nums.size(); i++) {
            // 跳过重复的元素，避免结果重复
            if (i > 0 && nums[i] == nums[i - 1]) continue;

            int left = i + 1, right = nums.size() - 1;
            while (left < right) {
                int sum = nums[i] + nums[left] + nums[right];
                if (sum == 0) {
                    res.push_back({nums[i], nums[left], nums[right]});
                    // 跳过重复的元素
                    while (left < right && nums[left] == nums[left + 1]) left++;
                    while (left < right && nums[right] == nums[right - 1]) right--;
                    left++;
                    right--;
                } else if (sum < 0) {
                    left++;  // 需要更大的数
                } else {
                    right--;  // 需要更小的数
                }
            }
        }

        return res;
    }
};

```

##### 8. 四数之和   (  和三数和一样要重新做)

![image-20250218105352327](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250218105352327.png)

```c++
class Solution {
public:
    vector<vector<int>> fourSum(vector<int>& nums, int target) {
        ranges::sort(nums);
        vector<vector<int>> ans;
        int n = nums.size();
        for (int a = 0; a < n - 3; a++) { // 枚举第一个数
            long long x = nums[a]; // 使用 long long 避免溢出
            if (a > 0 && x == nums[a - 1]) continue; // 跳过重复数字
            if (x + nums[a + 1] + nums[a + 2] + nums[a + 3] > target) break; // 优化一
            if (x + nums[n - 3] + nums[n - 2] + nums[n - 1] < target) continue; // 优化二
            for (int b = a + 1; b < n - 2; b++) { // 枚举第二个数
                long long y = nums[b];
                if (b > a + 1 && y == nums[b - 1]) continue; // 跳过重复数字
                if (x + y + nums[b + 1] + nums[b + 2] > target) break; // 优化一
                if (x + y + nums[n - 2] + nums[n - 1] < target) continue; // 优化二
                int c = b + 1, d = n - 1;
                while (c < d) { // 双指针枚举第三个数和第四个数
                    long long s = x + y + nums[c] + nums[d]; // 四数之和
                    if (s > target) d--;
                    else if (s < target) c++;
                    else { // s == target
                        ans.push_back({(int) x, (int) y, nums[c], nums[d]});
                        for (c++; c < d && nums[c] == nums[c - 1]; c++); // 跳过重复数字
                        for (d--; d > c && nums[d] == nums[d + 1]; d--); // 跳过重复数字
                    }
                }
            }
        }
        return ans;
    }
};


```

#### 4.字符串

##### 1.反转字符串

![image-20250224153138676](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250224153138676.png)

```c++
class Solution {
public:
    void reverseString(vector<char>& s) {
        int left=0;
        int right=s.size()-1;
        while(left<=right)
        {   
            char temp= s[left];
            s[left]=s[right];
            s[right]=temp;
            left++;
            right--;
        }
    }
};

```

```c++
void reverseString(vector<char>& s) {
    for (int i = 0, j = s.size() - 1; i < s.size()/2; i++, j--) {
        swap(s[i],s[j]);
    }
}
```

##### 2. 反转字符串II  ***



![image-20250224153911677](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250224153911677.png)

```c++
class Solution {
public:
    // 反转字符串的辅助函数
    void reverse(string &str, int left, int right) {
        while (left < right) {
            swap(str[left], str[right]);
            left++;
            right--;
        }
    }

    string reverseStr(string s, int k) {
        for (int i = 0; i < s.size(); i += 2 * k) {
            // 确定反转的范围，反转前 k 个字符
            reverse(s, i, min(i + k - 1, (int)s.size() - 1));//这个思想太牛了
        }
        return s;
    }
};
```

##### 3.替换数字(扩容的大小=  number -1 ) *



![image-20250224161923194](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250224161923194.png)

字母不变数字替换成number  (连续空间 是要扩容的)

![img](https://code-thinking-1253855093.file.myqcloud.com/pics/20231030173058.png)

有同学问了，为什么要从后向前填充，从前向后填充不行么？

从前向后填充就是O(n^2)的算法了，因为每次添加元素都要将添加元素之后的所有元素整体向后移动。

**其实很多数组填充类的问题，其做法都是先预先给数组扩容带填充后的大小，然后在从后向前进行操作。**

这么做有两个好处：

1. 不用申请新数组。
2. 从后向前填充元素，避免了从前向后填充元素时，每次添加元素都要将添加元素之后的所有元素向后移动的问题。

```c++
#include <iostream>
using namespace std;
int main() {
    string s;
    while (cin >> s) {
        int sOldIndex = s.size() - 1;
        int count = 0; // 统计数字的个数
        for (int i = 0; i < s.size(); i++) {
            if (s[i] >= '0' && s[i] <= '9') {
                count++;
            }
        }
        // 扩充字符串s的大小，也就是将每个数字替换成"number"之后的大小
        s.resize(s.size() + count * 5);
        int sNewIndex = s.size() - 1;
        // 从后往前将数字替换为"number"
        while (sOldIndex >= 0) {
            if (s[sOldIndex] >= '0' && s[sOldIndex] <= '9') {
                s[sNewIndex--] = 'r';
                s[sNewIndex--] = 'e';
                s[sNewIndex--] = 'b';
                s[sNewIndex--] = 'm';
                s[sNewIndex--] = 'u';
                s[sNewIndex--] = 'n';
            } else {
                s[sNewIndex--] = s[sOldIndex];
            }
            sOldIndex--;
        }
        cout << s << endl;       
    }
}


```

##### 4.翻转字符串里的单词

![image-20250224170914899](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250224170914899.png)

```c++
class Solution {
public:

    string reverseWords(string s) {
        //先分割
        vector<string> str;
        int num=0;
        string temp="";
        for(int i=0;i<s.size();i++)
        {
            if(s[i]!=' ')
            {
                temp+=s[i];
            }
            else if(s[i]==' '&&temp.size()!=0)
            {
                // str.push_front(temp);
                str.insert(str.begin(),temp);  //注意string没有push
                temp="";
            }

        }

        if(s[s.size()-1]!=' ')
        {
        str.insert(str.begin(),temp);
        }

        for(int i=0;i<str.size();i++)
        {
        cout<<str[i]<<endl;
        }

        string res;
        //反转
        for(int i=0;i<str.size()-1;i++)
        {

            res+=str[i];
            res+=" ";
        }
        return res+str[str.size()-1];
    }
};
```

##### 5.右旋转字符串（思路 反转  反转  反转 ）

![image-20250224190613914](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250224190613914.png)

```c++
#include<iostream>
#include<string>
using namespace std;

    //倒叙数组
    void reverse(string &s,int left,int right)
    {
        for(;left<=right;left++,right--)
        {
            swap(s[left],s[right]);
        }
    }
    
int main()
{
    int k=0;
    cin>>k;
    string str;
    cin>>str;
    

    reverse(str,0,str.size()-1);
    reverse(str,0,k-1);
    reverse(str,k,str.size()-1);
    for(char c:str)
    {
        cout<<c;
    }
    return 0;
}
```

![image-20250224192619297](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250224192619297.png)

##### 6.实现strStr()

![image-20250224192703545](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250224192703545.png)

```c++
class Solution {
public:

    int strStr(string haystack, string needle) {
        int needle_size=needle.size();
        int haystack_size=haystack.size();
        if(needle_size>haystack_size) return -1;
        for(int i=0;i<haystack_size;i++)
        {
            if(haystack.substr(i, needle.size()) == needle)//起始位置  长度
            {return i;}

        }
        return -1;
    }
};
```

##### 7.重复的子字符串

![image-20250224204150435](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250224204150435.png)

```c++
// class Solution {
// public:
//     bool isrepetsubstr(string substr,string s)
//     {
//         int substr_size=substr.size();
        
//         for(int i=0;i<s.size();i+=substr_size)
//         {
//             if(s.substr(i,substr_size)!=substr)
//             {
//                 return false;
//             } 

//         }
//         return true;
//     }
//     bool repeatedSubstringPattern(string s) {
//         string substr1="";
//         for(int i=0;i<s.size();i++)
//         {
//             substr1=s.substr(0,i+1);
//             if(s.size()%substr1.size()!=0) continue;
//             bool res=isrepetsubstr(substr1,s);
//             if(res==true) return true;
//         }
//         return false;
//     }
// };
class Solution {
public:
    bool isrepetsubstr(string substr, string s) {
        int substr_size = substr.size();
        
        // 遍历字符串，检查是否所有的子串都匹配
        for (int i = 0; i < s.size(); i += substr_size) {
            if (s.substr(i, substr_size) != substr) {  // 比较当前子串与substr
                return false;
            }
        }
        return true;
    }

    bool repeatedSubstringPattern(string s) {
        int n = s.size();
        
        // 检查所有可能的子串长度
        for (int i = 1; i <= n / 2; i++) {  // 不需要检查长度大于n/2的子串
            if (n % i == 0) {  // 如果s的长度能够被i整除
                string substr = s.substr(0, i);  // 获取长度为i的子串
                if (isrepetsubstr(substr, s)) {  // 检查是否重复出现
                    return true;
                }
            }
        }
        return false;
    }
};



```



#### 5. 双指针法

![image-20250224210441310](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250224210441310.png)

##### 1.移除元素（秒）

![image-20250224210531252](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250224210531252.png)

```c++
class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        int left=0,right=0;
        for(;right<nums.size();)
        {
            if(nums[right]==val)
            {
                right++;
                continue;
            }
            else
            {
                nums[left++]=nums[right++];
            }
        }
        return left;
    }
};
```

##### 2. 反转字符串

![image-20250224213544178](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250224213544178.png)

```c++
class Solution {
public:
    void reverseString(vector<char>& s) {
        int left=0;
        int right=s.size()-1;
        while(left<=right)
        {   
            char temp= s[left];
            s[left]=s[right];
            s[right]=temp;
            left++;
            right--;
        }
    }
};
```

##### 3.  替换数字

![image-20250224213724885](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250224213724885.png)

##### 4.反转字符串里的单词（怎么用双指针） 感觉没我自己的好用

![image-20250224213902474](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250224213902474.png)

```c+=
class Solution {
public:
    void reverse(string& s, int start, int end){ //翻转，区间写法：左闭右闭 []
        for (int i = start, j = end; i < j; i++, j--) {
            swap(s[i], s[j]);
        }
    }

    void removeExtraSpaces(string& s) {//去除所有空格并在相邻单词之间添加空格, 快慢指针。
        int slow = 0;   //整体思想参考https://programmercarl.com/0027.移除元素.html
        for (int i = 0; i < s.size(); ++i) { //
            if (s[i] != ' ') { //遇到非空格就处理，即删除所有空格。
                if (slow != 0) s[slow++] = ' '; //手动控制空格，给单词之间添加空格。slow != 0说明不是第一个单词，需要在单词前添加空格。
                while (i < s.size() && s[i] != ' ') { //补上该单词，遇到空格说明单词结束。
                    s[slow++] = s[i++];
                }
            }
        }
        s.resize(slow); //slow的大小即为去除多余空格后的大小。
    }

    string reverseWords(string s) {
        removeExtraSpaces(s); //去除多余空格，保证单词之间之只有一个空格，且字符串首尾没空格。
        reverse(s, 0, s.size() - 1);
        int start = 0; //removeExtraSpaces后保证第一个单词的开始下标一定是0。
        for (int i = 0; i <= s.size(); ++i) {
            if (i == s.size() || s[i] == ' ') { //到达空格或者串尾，说明一个单词结束。进行翻转。
                reverse(s, start, i - 1); //翻转，注意是左闭右闭 []的翻转。
                start = i + 1; //更新下一个单词的开始下标start
            }
        }
        return s;
    }
};
```



##### 5.反转链表

![image-20250224214114663](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250224214114663.png)



```c++
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        ListNode *cur=NULL;
        ListNode *pre=head;
        while(pre!=NULL)
        {
            ListNode *temp=pre->next;
            pre->next=cur;
            cur=pre;
            pre=temp;

        }
        return cur;
    }
};
```

##### 6.删除链表中的倒数第N个节点

![image-20250224214834322](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250224214834322.png)

##### 7.链表相交

![image-20250227212402242](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250227212402242.png)

```c++
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        if (!headA || !headB) {
            return NULL;  // If either list is empty, there is no intersection.
        }
        
        ListNode *curA = headA;
        ListNode *curB = headB;
        
        // Traverse through both lists. If one pointer reaches the end, switch it to the other list.
        while (curA != curB) {
            // When curA reaches the end of list A, move it to the head of list B
            // Similarly, when curB reaches the end of list B, move it to the head of list A
            curA = curA ? curA->next : headB;
            curB = curB ? curB->next : headA;
        }
        
        // If curA == curB, either both are NULL (no intersection) or both are at the intersection node.
        return curA;
    }
};

```





##### 8.环形链表

![image-20250227214057553](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250227214057553.png)

```c++
class Solution {
public:
    ListNode *detectCycle(ListNode *head) {
        if (head == NULL || head->next == NULL) return NULL;
        
        unordered_set<ListNode*> res;
        
        while (head != NULL) {
            // If the node is already in the set, we found a cycle
            if (res.find(head) != res.end()) {
                return head;  // Return the node where the cycle begins
            }
            
            // Otherwise, insert the node into the set
            res.insert(head);
            head = head->next;  // Move to the next node
        }
        
        return NULL;  // No cycle detected
    }
};

```

#### 栈与队列

##### 1.栈与队列理论基础

![image-20250303190628385](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250303190628385.png) 

STL的三个版本



1. HP STL 最早的 开源的 其他都是参照它的

2. PJ... STL 参照HP实现，被VISUAL C++编译器采用 不是开源的
3. sgi 参照HP实现，linux的c++编译器GCC采用实现 

![image-20250303191456658](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250303191456658.png)

不提供迭代器   不是容器（是由容器实现的）

![image-20250303191712472](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250303191712472.png)

![image-20250303191818954](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250303191818954.png)

![image-20250303192049975](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250303192049975.png)

##### 2.用栈实现队列（秒）

![image-20250303194151464](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250303194151464.png)

```c++
class MyQueue {
public:
    int length=0;
    stack<int> st;

public:
    MyQueue() {
        this->length=0;

    }
    
    void push(int x) {
        st.push(x);
        length++;
    }
    
    int pop() {
        
        stack<int> temp;
        while(!st.empty())
        {
            int top=st.top();
            st.pop();
            temp.push(top);
        }
        length--;
        int res=temp.top();
        temp.pop();
        while(!temp.empty())
        {
            int top=temp.top();
            temp.pop();
            st.push(top);
        }
        return res;
    }
    
    int peek() {
        
                
        stack<int> temp;
        while(!st.empty())
        {
            int top=st.top();
            st.pop();
            temp.push(top);
        }

        int res=temp.top();
        while(!temp.empty())
        {
            int top=temp.top();
            temp.pop();
            st.push(top);
        }
        return res;

    }
    
    bool empty() {
        if(length==0) return true;
        else
        {
            return false;
        }
    }
};

/**
 * Your MyQueue object will be instantiated and called as such:
 * MyQueue* obj = new MyQueue();
 * obj->push(x);
 * int param_2 = obj->pop();
 * int param_3 = obj->peek();
 * bool param_4 = obj->empty();
 */
```

##### 3. 用队列实现栈  (队列的操作  q.pop()  q.front() q.push())

![image-20250303194214668](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250303194214668.png)

![image-20250303194252403](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250303194252403.png)

```c++
class MyStack {
public:
    int length;
    queue<int> q;
public:
    MyStack() {
        this->length=0;
    }
    
    void push(int x) {
        q.push(x);
        length++;
    }
    
    int pop() {
        queue<int> temp;
        for(int i=0;i<length-1;i++)
        {
            int num=q.front();
            q.pop();
            temp.push(num);
        }
         int res=q.front();
         q.pop();
         length--;
        while(!temp.empty())
        {
            int num=temp.front();
            temp.pop();
            q.push(num);
        }
        return res;

    }
    
    int top() {
        queue<int> temp;
        for(int i=0;i<length-1;i++)
        {
            int num=q.front();
            q.pop();
            temp.push(num);
        }
        int res=q.front();
        q.pop();
        temp.push(res);
        while(!temp.empty())
        {
            int num=temp.front();
            temp.pop();
            q.push(num);
        }
        return res;

    }
    
    bool empty() {
        return length==0?true:false;
    }
};

/**
 * Your MyStack object will be instantiated and called as such:
 * MyStack* obj = new MyStack();
 * obj->push(x);
 * int param_2 = obj->pop();
 * int param_3 = obj->top();
 * bool param_4 = obj->empty();
 */
```

##### 4. 有效的括号 （ 有时候会以“】{”的形式出现  右边括号先出现不合法 ）

![image-20250303200014386](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250303200014386.png)

```c++
class Solution {
public:
    bool isValid(string s) {
        stack<char> st;
        if(s.size()%2!=0) return false;
        for(auto str:s)
        {
            if(str==')')
            {
                if(st.empty()) return false;
                if(st.top()=='(')
                {st.pop();}
                else
                {st.push(str);}
            }
            else if(str==']')
            {
                if(st.empty()) return false;
                if(st.top()=='[')
                {st.pop();}
                else
                {st.push(str);}
            }
            else if(str=='}')
            {
                if(st.empty()) return false;
                if(st.top()=='{')
                {st.pop();}
                else
                {st.push(str);}
            }
            else st.push(str);
        }
        return st.empty();
    }
};
```

##### 、5. 删除字符串中所有相邻重复项

![image-20250303201348389](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250303201348389.png)

```c++
class Solution {
public:
    string removeDuplicates(string s) {
        
        stack<char> res;
        string out;
        for(auto str:s)
        {
            if(res.empty())
            {res.push(str);}
            else
            {
                if(str==res.top())
                {
                    res.pop();
                }
                else{
                    res.push(str);
                }
            }
        }
        while(!res.empty())
        {
            out+=res.top();
            res.pop();
        }
        reverse(out.begin(),out.end());
        return  out;//reverse函数的使用
    }
};
```

##### 6.逆波兰波表达式求值  (直接是int类型 那最后为什么要 stoi转换)        st.push(stoi(s));

![image-20250303202539039](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250303202539039.png)

```c++
#include <stack>
#include <string>
#include <vector>
#include <cstdlib>  // for std::stoi

class Solution {
public:
    int evalRPN(vector<string>& tokens) {
        stack<int> st;  // 使用整数栈
        for (auto s : tokens) {
            // 判断当前符号是否是运算符
            if (s == "+" || s == "-" || s == "*" || s == "/") {
                int num2 = st.top(); st.pop();  // 弹出第二个操作数
                int num1 = st.top(); st.pop();  // 弹出第一个操作数
                
                // 执行运算
                if (s == "+") {
                    st.push(num1 + num2);
                } else if (s == "-") {
                    st.push(num1 - num2);
                } else if (s == "*") {
                    st.push(num1 * num2);
                } else if (s == "/") {
                    st.push(num1 / num2);
                }
            } else {
                // 如果是数字，就将其转换为整数并推入栈中
                st.push(stoi(s));  // 使用 stoi 进行字符串转整数
            }
        }
        
        // 最后栈中只会剩下一个元素，就是计算结果
        return st.top();
    }
};

```

##### 7滑动窗口最大值（困难）

https://leetcode.cn/problems/sliding-window-maximum/solutions/543426/hua-dong-chuang-kou-zui-da-zhi-by-leetco-ki6m/



![image-20250303205918630](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250303205918630.png)



![image-20250303211920126](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250303211920126.png)

##### 8. 前k个高频元素   堆  优先队列   很好的练习题

https://leetcode.cn/problems/top-k-frequent-elements/solutions/19328/python-dui-pai-xu-by-xxinjiee/



![image-20250303213135177](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250303213135177.png)

![image-20250303213149696](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250303213149696.png)

![image-20250303213327652](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250303213327652.png)

#### 二叉树（深搜广搜）

1. 二叉树遍历（前 中 后  层序）

2. 二叉树的属性（对称二叉树、二叉树最大深度、二叉树最小深度、完全二叉树节点个数、平衡二叉树、二叉树的所有路径、左叶子之和、找树左下角的值、路经总和）
3. 二叉树的修改与构造（翻转二叉树、中序与后序遍历构造、最大二叉树、合并二叉树）
4. 二叉搜索树的特性（二叉搜索树中的搜索、验证二叉搜索树、二叉搜索树中的最小绝对差、二叉搜索树中的众数、把二叉搜索树转换为累加树）
5. 二叉树公共祖先问题（二叉树的最近公共祖先、二叉搜索树的最近公共祖先）
6. 二叉搜索树的修改与改造（插入、删除、修剪、构造（有序树转为二叉哈搜索树））

![image-20250313145800312](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250313145800312.png)



满二叉树  

```
如果一棵二叉树只有度为0的结点和度为2的结点，并且度为0的结点在同一层上，则这棵二叉树为满二叉树。
```

![image-20250313150404448](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250313150404448.png)



完全二叉树

```
在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层（h从1开始），则该层包含 1~ 2^(h-1) 个节点。
```



  

二叉搜索树的定义：

```
前面介绍的树，都没有数值的，而二叉搜索树是有数值的了，二叉搜索树是一个有序树。

若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；
若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；
它的左、右子树也分别为二叉排序树
```

平衡二叉搜索树（有什么用呢

）

```
又被称为AVL（Adelson-Velsky and Landis）树，且具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。
```

![image-20250313150812051](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250313150812051.png)

##### 1. 二叉树的遍历

###### 1.二叉树的递归遍历（前中后的递归写法）

递归三部曲：

（递归函数的参数值、返回值）

（终止条件）

（单层递归逻辑）

[144.二叉树前序遍历](https://leetcode.cn/problems/binary-tree-preorder-traversal/description/)

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    void traversal(TreeNode* node,vector<int> & res)
    {
        if(node==nullptr) return ;
        res.push_back(node->val);
        traversal(node->left,res);
        traversal(node->right,res);
    }
    vector<int> preorderTraversal(TreeNode* root) {
        vector<int> res;
        traversal(root,res);
        return res;

    }
};
```

145.后序

```c++

class Solution {
public:
    void traversal(TreeNode* node,vector<int> &res)
    {
        if(node==nullptr) return ;
        traversal(node->left,res);
        traversal(node->right,res);
        res.push_back(node->val);
    }
    vector<int> postorderTraversal(TreeNode* root) {
        vector<int>res;
        traversal(root,res);
        return res;
    }
};
```

[94.中序遍历](https://leetcode.cn/problems/binary-tree-inorder-traversal/description/)

```c++
class Solution {
public:
    void trasval(TreeNode * node,vector<int> &res)
    {
        if (node==nullptr) return ;
        trasval(node->left,res);
        res.push_back(node->val);
        trasval(node->right,res);
    }
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int>res;
        trasval(root,res);
        return res;
        
    }
};
```

###### 二叉树迭代遍历（用栈实现 ）

前序（迭代） 先进右子树 再进左子树// 

```c++
class Solution {
public:
    vector<int> preorderTraversal(TreeNode* root) {
        vector<int>res;
        if(root==nullptr) return res;
        stack<TreeNode*> st;
        st.push(root); //前序  先进幼在进左
        while(!st.empty())
        {
            TreeNode* cur=st.top();
            st.pop();
            res.push_back(cur->val);
            if(cur->right!=nullptr)st.push(cur->right);
            if(cur->left!=nullptr)st.push(cur->left);
        }
        return res;

    }
};
```



后续  和前序有一定的反转关系

 前序  中左右-》中右左-》翻转

```c++
class Solution {
public:
    vector<int> postorderTraversal(TreeNode* root) {
        vector<int>res;
        stack<TreeNode*> st;
        if(root==nullptr)return res;
        st.push(root);
        while(!st.empty())
        {
            TreeNode* cur=st.top();
            st.pop();
            res.push_back(cur->val);
            if(cur->left)st.push(cur->left);
            if(cur->right)st.push(cur->right);
 
        }
        reverse(res.begin(),res.end());
        return res;
    }
};
```



中序（左中右）

```

```



### [Leetcode hot100](https://leetcode.cn/problems/intersection-of-two-linked-lists/description/?envType=problem-list-v2&envId=2cktkvj&)

#### 1. 哈希表  三道

##### 1. 

##### 2. 字母异位词（中等）

![image-20250228094937563](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250228094937563.png)

```c++
class Solution {
public:
    void isstrdif(string str,unordered_map<string,vector<string>>  & hash)
    {
        string s=str;
        sort(str.begin(),str.end());
        hash[str].push_back(s);
    }
    vector<vector<string>> groupAnagrams(vector<string>& strs) {
        vector<vector<string>> res;
        vector<string> temp;
        unordered_map<string,vector<string>> hash;
        if(strs.size()==0) return {{""}};
        for(auto s:strs)
        {
            isstrdif(s,hash);
        }

        for(auto key:hash)
        {
            res.push_back(key.second);
        }
        return res;

    }
};
```



##### 3. 最长连续序列（中）



#### 2.双指针

##### 1.移动0

![image-20250303185312513](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250303185312513.png)

```c++
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        int left=0;
        int right=0;
        while(right<nums.size())
        {
            if(nums[right]!=0)
            {
                swap(nums[left++],nums[right++]);
            }
            else
            {
            right++;
            }
        }
    }
};
```

##### 2.成水最多的容器

![image-20250303190259208](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250303190259208.png)



## 三、基础知识

### [【技能进阶1】面试不问，默认你会的技能：Git](https://www.nowcoder.com/discuss/683719113209864192)

### [【技能进阶2】面试不问，默认你会的技能：Docker](https://www.nowcoder.com/discuss/685505400984076288)

### [【技能进阶3】面试不问，默认你会的技能：Linux命令](https://www.nowcoder.com/discuss/702840449987301376?sourceSSR=users)

### [嵌入式模拟面试拷打【1】](https://www.nowcoder.com/discuss/656162857771364352?sourceSSR=search)

### [嵌入式模拟面试拷打【2】](https://www.nowcoder.com/discuss/658621010672943104?sourceSSR=search)

### [嵌入式模拟面试拷打【3】](https://www.nowcoder.com/discuss/659372083679395840?sourceSSR=search)

### [嵌入式模拟面试拷打【4】](https://www.nowcoder.com/discuss/665962511342059520?sourceSSR=search)

### [嵌入式模拟面试拷打【5】](https://www.nowcoder.com/discuss/668405148430958592?sourceSSR=search)

### [嵌入式模拟面试拷打【6】](https://www.nowcoder.com/discuss/668841553929994240?sourceSSR=search)

### [嵌入式模拟面试拷打【7】](https://www.nowcoder.com/discuss/682174283287670784?sourceSSR=users)

### [嵌入式模拟面试拷打【8】](https://www.nowcoder.com/discuss/682174899556732928?sourceSSR=users)

### [嵌入式模拟面试拷打【9】Linux系统性能问题排查思路](https://www.nowcoder.com/discuss/703272482492387328?sourceSSR=search)

### [嵌入式模拟面试拷打【10】Linux典型的故障处理场景](https://www.nowcoder.com/discuss/704610682431442944?sourceSSR=search)

### [嵌入式模拟面试拷打【11】操作系统](https://www.nowcoder.com/discuss/659372831020482560?sourceSSR=search)

### [嵌入式模拟面试拷打【12】Docker](https://www.nowcoder.com/discuss/684451200497897472?sourceSSR=search)

### [嵌入式模拟面试拷打【13】：SPI、UART、I2C通信的定义、应用与区别SPI、UART、I2C通信的定义、应用与区别](https://www.nowcoder.com/discuss/718485020645552128?sourceSSR=search)

### [AI大模型面试模拟拷打](https://www.nowcoder.com/discuss/694476338157076480?sourceSSR=search)



### c++基础语法（我的笔记上）

### 常规八股: [小林coding](https://xiaolincoding.com/)，操作系统，计网，数据库

![image-20250214152157297](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250214152157297.png)

## 四、预备做的项目

### [1. 手写操作系统项目 | 代码随想录](https://www.programmercarl.com/other/project_os.html#%E9%A1%B9%E7%9B%AE%E6%96%87%E6%A1%A3%E8%8E%B7%E5%8F%96%E6%96%B9%E5%BC%8F)  Mit6.s081



操作系统本身就是面试的必考知识，**尤其是面试后端开发、嵌入式开发等岗位时，更是如此**。

同时操作系统也是一个很不错的项目，如果是C++选手做这个项目的话，既可以用来投后端岗位，也可以投 嵌入式岗位，都是比较匹配的。

如果想好好学习操作系统，一定绕不开 Mit6.s081。

Mit6.s081 是麻省理工学院面向本科生的操作系统课程，其课程实验是在教学用操作系统xv6上进行扩展和优化。

Xv6 操作系统源代码只有一万余行，并且相对清晰和模块化，每个 lab 都带有自动评测功能，非常适合用于实践操作系统知识。

这是大家公认的高质量操作系统实践课。

项目代码全部开源，github地址：[https://github.com/youngyangyang04/KamaOS(opens new window)](https://github.com/youngyangyang04/KamaOS)

欢迎star，fork，去学习一波。

星球项目文档就分享在[知识星球](https://www.programmercarl.com/other/kstar.html)里。

今年秋招已经有录友用这个项目拿到offer了 ：



![image-20250214162256298](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250214162256298.png)

### 2. WebServer

为什么推荐做 WebServer？

1、**cpper 能够找到的项目（有详细资料的）确实不多**

对于科班 or 有充足实习经历 or 课题组项目丰富的同学来说，自然有许多相关的项目能够写在简历上。

但是对于项目经历贫乏的cpp转码选手来说，在网上能够找到的项目（有较详细资料的），无非就是比较简单的xx管理系统、五子棋等简易游戏、各种工具库、烂大街的WebServer，然后你就可以发现里面最高大上的还是 WebServer（还有个 RPC 框架）。

2、**能够将面试所需的基础知识串联起来**

WebServer 能够串联绝大部分的面试八股，语言（C/C++全覆盖，可以扩展至C++11/17）+操作系统（含有大量的 I/O 系统调用及其封装。

还有 EPOLL 等多路复用机制）+计算机网络（本身就是一个网络框架，对网络异常的处理）+数据库（注册中心的数据库语句、负载均衡等）。

当你的项目中涵盖了所有面试所需的基础知识后，面试官更倾向结合你的项目去考察知识，而不是东问一个西问一个，**这样可以将面试的问题限制在一定的范围中，一定程度上降低了面试准备的难度**。

3、**万物均能集成到 WebServer 中**

WebServer 的本质上是一个高性能网络框架，它提供了一个单服务端（当然也可以扩展为多服务端）与多客户端的高效连接框架，但是客户端与服务端连接上以后具体应该做些什么（也就是有哪些业务），这就可以由我们自由发挥了，这就是 WebServer 的功能扩展。

目前大多数的 WebServer 都将从服务端获取 MIME 作为主要功能。

但实际上，之前说到的游戏可以放到上面（是不是就有点像对战平台了），管理系统可以放到上面、存储引擎（卡哥的skipList：https://github.com/youngyangyang04/Skiplist-CPP ）等你能想到的都可以部署在 WebServer 上，这样看来，WebServer 本身具备相当的工作量。





## 正点原子视频



![6379727a431814e5f9a8db0f77dade5](D:\Program Files\wechat\WeChat Files\wxid_28c7brmd4irv22\FileStorage\Temp\6379727a431814e5f9a8db0f77dade5.png)

### [1. 正点原子 STM32](https://www.bilibili.com/video/BV1Lx411Z7Qa?spm_id_from=333.788.player.switch&vd_source=54dd3357d0d4c6dad497adff49640adf&p=2)

![72ee43410f131970582beb7edc11b39](D:\Program Files\wechat\WeChat Files\wxid_28c7brmd4irv22\FileStorage\Temp\72ee43410f131970582beb7edc11b39.jpg)

![b091fd560843bf81e2d83c1026d8cd8](D:\Program Files\wechat\WeChat Files\wxid_28c7brmd4irv22\FileStorage\Temp\b091fd560843bf81e2d83c1026d8cd8.jpg)

![ad162fe67602cb3e097a3b1260ce2b0](D:\Program Files\wechat\WeChat Files\wxid_28c7brmd4irv22\FileStorage\Temp\ad162fe67602cb3e097a3b1260ce2b0.jpg)







#### 5.第五讲

![image-20250218200528488](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250218200528488.png)

什么是ARM内核





###### 什么是stm32

![image-20250218200720096](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250218200720096.png)





###### cortex内核

![image-20250218201223251](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250218201223251.png)

###### stm32 vs ARM7



![image-20250218201728099](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250218201728099.png)

![image-20250218201955840](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250218201955840.png)![image-20250218202049808](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250218202049808.png)

![image-20250218202108887](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250218202129584.png)

##### stm32概述

###### 1.cm3芯片结构

![image-20250218202353967](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250218202353967.png)

###### 2.1 CM3芯片结构



###### 2.2 STM32F10x的2个产品线介绍



###### 2.3 STM32F10x各芯片之间的关联

![image-20250218203342598](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250218203342598.png)

###### 2.4 STM32命名规则

![image-20250218203201154](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250218203201154.png)

![image-20250218203311194](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250218203311194.png)

###### 3 .1应用





![image-20250218203458060](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250218203458060.png)

###### 3.2优势

![image-20250218203747275](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250218203747275.png)



#### 6.第六讲 STM32芯片解读

![image-20250218204323778](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250218204323778.png)





#####  1.芯片有哪些资源?

![image-20250218204440870](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250218204440870.png)

![image-20250218204550356](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250218204550356.png)



![image-20250218204818834](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250218204818834.png)

![image-20250218204849546](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250218204849546.png)

![image-20250218205053862](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250218205053862.png)

![image-20250218205210430](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250218205210430.png)

![image-20250218205246610](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250218205246610.png)





##### 2.芯片内部结构怎样?

![image-20250218205349715](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250218205349715.png)



![image-20250218205557538](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250218205557538.png)



##### 3.芯片引脚和功能怎么对应?





##### 4.STM32最小系统设计



![image-20250218210405313](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250218210405313.png)

#### 7.第七讲   开发环境搭建

##### 1.MDK软件安装



![image-20250218211158364](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250218211158364.png)



##### 2.USB串口驱动安装



##### 3.JLINK驱动安装

####  8.第八讲（串口下载程序）

#### 9.第九讲  JLINK程序下载

#### 10.新建库函数模板

![image-20250218212446802](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250218212446802.png)

#### 11. 第十一讲 新建寄存器模板



#### 12.  *  第十二讲 GPIO基本原理和寄存器配置

##### 1. GPIO基本结构和工作方式

![](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250218215836474.png)

![image-20250218215923596](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250218215923596.png)



![image-20250218215951212](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250218215951212.png)

FT （表示可容忍5V）





![image-20250218220444677](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250218220444677.png)



![image-20250218220534032](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250218220534032.png)

![image-20250218220645476](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250218220645476.png)



![image-20250218220809534](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250218220809534.png)





![image-20250218220850802](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250218220850802.png)





![image-20250219090648014](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219090648014.png)

当输出输出数据寄存器（ODR）1 ，IO 由外接电阻决定电压 （开漏输出要接电阻） （高阻态）

![image-20250219090801893](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219090801893.png)  

当输出输出数据寄存器（ODR）0 ，IO 拉到VSS =0   



![](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250218222227773.png)

https://i.imgur.com/c87tJ8O.jpeg  （和上面一样）



![image-20250218222306350](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250218222306350.png)



![image-20250218222053005](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250218222053005.png)



![image-20250218222656004](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250218222656004.png)

##### 2. GPIO寄存器说明

![image-20250219091626810](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219091626810.png)

![image-20250219091758536](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219091758536.png)





![image-20250219091947162](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219091947162.png)



输入数据寄存器与输出数据寄存器ODR一起配合使用  上图中引脚设置为 10 00 （上拉还是下拉 这时候就要配置输出数据寄存器ODR是 0 还是1 ）

![image-20250219092121220](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219092121220.png)

![image-20250219092325810](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219092325810.png)



当输出模式：

![image-20250219092226894](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219092226894.png)



位设置或清楚寄存器

![image-20250219092641307](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219092641307.png)

![image-20250219092702109](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219092702109.png)

设置ODR

![image-20250219092836171](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219092836171.png)

odr  （读数据，分析  写  写0  有影响 ）   bsrr 0不影响  （可以保持不变） 

![image-20250219093232702](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219093232702.png)

与bsrr的高位一样的功能









##### 3. STM32F10xGPIO引脚说明

###### 端口复用

![image-20250219093404128](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219093404128.png)

![image-20250219093419045](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219093419045.png)

###### 端口映射



![image-20250219093504117](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219093504117.png)



![image-20250219093513564](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219093513564.png)

#### 14. 第十四讲跑马灯寄存器版本

寄存器先使能GPIO时钟使能



先清零  在设置   3 -》00 11  输出推完 50HZ



![image-20250219195355094](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219195355094.png)

![image-20250219195524888](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219195524888.png)

非运算![image-20250219195815465](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219195815465.png)   清0 



![image-20250219195915745](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219195915745.png)

#### 第十五讲 跑马灯位操作（操作相关寄存器）

![image-20250219200318680](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219200318680.png)

不要求非常理解（会用就行）

![image-20250219200820803](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219200820803.png)

把某一个位膨胀为一个地址 直接操作地址

![image-20250219200859918](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219200859918.png)

![image-20250219200952526](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219201010650.png)



![image-20250219201133398](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219201133398.png)

![image-20250219201436117](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219201436117.png)

![image-20250219201600036](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219201600036.png)

![image-20250219202418163](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219202418163.png)





#### 16. 第十六讲  蜂鸣器实验   R38电阻   浮空时不响

![image-20250219202609345](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219202609345.png)



![image-20250219202645812](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219202645812.png)

三极管放大电压

![image-20250219202729657](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219202729657.png)

![image-20250219202851481](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219202851481.png)

![image-20250219202859644](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219202859644.png)

![image-20250219203032292](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219203032292.png)

![image-20250219203215203](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219203215203.png)





位操作映射：

![image-20250219203254394](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219203254394.png)

寄存器ODR   /库函数setbits()



#### 17. 第十七讲 按键输入实验  （外部中断）

![image-20250219203559836](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219203559836.png)

 ![image-20250219203815283](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219203815283.png)

![image-20250219204207719](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219204207719.png)![image-20250219204318576](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219204318576.png)



![image-20250219204413295](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219204413295.png)



![image-20250219204723149](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219204723149.png)

第二次调用不会重新初始化（只会一次）



![image-20250219204854645](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219204854645.png)

![image-20250219204933401](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219204933401.png)![image-20250219205103619](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219205103619.png)![image-20250219205406210](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219205406210.png)![image-20250219205511049](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219205511049.png)![image-20250219205531958](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219205531958.png)

#### 18. 第十八讲  C语言的复习 + 寄存器地址名称映射分析



![image-20250219205752693](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219205752693.png)

![image-20250219205844121](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219205844121.png)

![image-20250219205916473](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219205916473.png) 

![image-20250219210329334](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219210329334.png)

![image-20250219210428769](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219210428769.png)

![image-20250219210604540](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219210604540.png)

![image-20250219210638973](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219210638973.png)

![image-20250219210744025](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219210744025.png)

![image-20250219210815738](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219210815738.png)

![image-20250219211033296](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219211033296.png)

![image-20250219211232370](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219211232370.png)

![image-20250219211318119](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219211318119.png)

![image-20250219211608247](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219211608247.png)

![image-20250219211758271](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219211758271.png)

![image-20250219212048887](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219212048887.png)







#### 19.第十九讲  时钟系统

![image-20250219212238220](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219212238220.png)

![image-20250219213003766](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219213003766.png)

![image-20250219213014975](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219213014975.png)

蓝色是时钟源   来自系统时钟

HSI RC  

![image-20250219213116849](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219213116849.png)



HSE RC  外部时钟  晶振

![image-20250219213213214](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219213213214.png)



PLL倍频器  放大（2-  16 ）

![image-20250219213316558](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219213316558.png)

![image-20250219213351415](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219213351415.png)



![image-20250219213423863](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219213423863.png)



RTC时钟来源   低速外部时钟  低俗内部时钟  HSE128分频

![image-20250219213558569](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219213558569.png)





输出内部时钟  PA8   MCO 

![image-20250219213815031](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219213815031.png)





##### 右侧分频

![image-20250219213956932](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219213956932.png)

![image-20250219213940838](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219213940838.png)

![image-20250219214122385](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219214122385.png)

![image-20250219214201376](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219214201376.png) ![image-20250219214405421](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219214405421.png)

![image-20250219214449249](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219214449249.png)

![image-20250219214532692](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219214532692.png)

![image-20250219214733722](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219214733722.png)



![image-20250219214837902](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219214837902.png)

 ![image-20250219215025226](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219215025226.png)

![image-20250219215142736](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219215142736.png)

![image-20250219215219086](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219215219086.png)

![image-20250219215509854](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219215509854.png)







![image-20250219215301663](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219215301663.png)



####  20. 第20讲 SystemInit 时钟系统初始化函数剖析

![image-20250219220511808](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219220511808.png) ![image-20250219220500739](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219220500739.png)

![QQ_1739973926003](C:\Users\86183\AppData\Local\Temp\QQ_1739973926003.png)

![image-20250219220653301](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219220653301.png)



先打开内部高速的8M时钟

![image-20250219221107094](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219221107094.png)

**![image-20250219221121175](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250219221121175.png)**



#### 21. 第21讲 systick 定时器（滴答定时器）  delay是用滴答时钟完成的 低功耗-》

![image-20250220193135003](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220193135003.png)

![image-20250220193333428](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220193333428.png)



![image-20250220193751896](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220193751896.png)





![image-20250220193924501](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220193924501.png)



CTRL  控制使能  （0 位-》使能   1位   是否中断   2 clocesouirce 选择时钟源    16  标志位   ）

![image-20250220194121827](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220194121827.png)

![image-20250220194235339](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220194235339.png)





2.load  

![image-20250220194356329](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220194356329.png)



3. value

   ![image-20250220194413288](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220194413288.png)

   ![image-20250220194519312](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220194519312.png)

![image-20250220195032632](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220195032632.png)

![image-20250220195305034](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220195305034.png)

![image-20250220195350643](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220195350643.png)

![image-20250220195625868](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220195625868.png)











![image-20250220195754277](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220195754277.png)

![image-20250220195832966](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220195832966.png)

![image-20250220195938111](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220195938111.png)





#### 22.第22讲  程序调试的方法（不看）

![image-20250220200022035](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220200022035.png)





#### 23. 第二三讲  端口复用和重映射

![image-20250220200444242](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220200444242.png)

1. 什么叫端口复用  ：  最大利用 端口   内置外设

   有很多**内置外设**（串口  ADC  DAC 。。。。。。）

   ![image-20250220200617856](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220200617856.png)

   ![image-20250220200845490](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220200845490.png)

   

2. 配置端口复用

![image-20250220200919263](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220200919263.png)

![image-20250220201003490](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220201003490.png)



![image-20250220201041750](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220201041750.png)



![image-20250220201130627](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220201130627.png)



2.端口重映射  （方便不先）



![image-20250220201222364](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220201222364.png)

![image-20250220201347853](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220201347853.png)

![image-20250220201440893](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220201440893.png)



![image-20250220201546386](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220201546386.png)



![image-20250220201610012](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220201610012.png)



AFIOshizhomgh  dakaide 三种情况

![image-20250220201643281](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220201643281.png)



#### 24. NVIC终端管理  *****************  重要i

![image-20250220201904269](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220201904269.png)

终端优先分组 设置管理  

![image-20250220202136440](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220202136440.png)



F103可屏蔽中断  60个

![image-20250220202237789](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220202237789.png)



##### 1.中断优先级分组  SCB->AIRCR寄存器  分组

![image-20250220202347447](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220202347447.png)



抢占和相应优先级

![image-20250220202447008](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220202447008.png)

![image-20250220202552020](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220202552020.png)

##### 抢占优先级

![image-20250220203154017](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220203154017.png)

![image-20250220203220908](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220203220908.png)

响应优先级只有当抢占优先级相同时才有意义    （高不可以打断低  同时发生时  高相应先发生）

![image-20250220203606939](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220203606939.png)



分组函数

 ![image-20250220203806865](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220203806865.png)

![image-20250220203819367](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220203819367.png)

设置寄存器

![image-20250220203943515](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220203943515.png)

![image-20250220204102942](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220204102942.png)

![image-20250220204140024](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220204140024.png)

![image-20250220204238946](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220204238946.png)



![image-20250220204344320](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220204344320.png)

![image-20250220204451476](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220204451476.png)

 ![image-20250220204709802](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220204709802.png)





例子

![image-20250220204903586](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220204903586.png)

![image-20250220204831448](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220204831448.png)





#### 25.串行通信原理

![image-20250220205416698](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220205416698.png)



通信双方一般有两种通信方式（并行 创行）

![image-20250220205730777](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220205730777.png)

![image-20250220205759753](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220205759753.png)

串行通信

单工

![image-20250220205917200](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220205917200.png)

![image-20250220205938345](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220205938345.png)



 串行通信的通信方式  根据时钟信号来手法数据

![image-20250220210200197](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220210200197.png)

![image-20250220210253034](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220210253034.png)





异步通信的双方一定要约定好波特率（ 同步通信靠时钟） AB 可以根据波特率采取数据



![image-20250220210602323](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220210602323.png) 



USRT可以作为UART来用

![image-20250220210636140](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220210636140.png)

![image-20250220210759241](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220210759241.png)

![image-20250220211144799](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220211144799.png)

 ![image-20250220211327530](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220211327530.png)



奇偶校验  检查数据的准确性

![image-20250220211452776](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220211452776.png)

![image-20250220211512521](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220211512521.png)







![image-20250220211742542](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220211742542.png)

![image-20250220211729860](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220211729860.png)

![image-20250220211826636](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220211826636.png)

![image-20250220212014948](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220212014948.png)![image-20250220212135433](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220212135433.png)

![image-20250220212228184](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220212228184.png)



#### 26. 第26讲  串口体哦那更新寄存器库函数配置  实验



常用寄存器： 状态寄存器   数据寄存器   波特率寄存器

![image-20250220214229423](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220214229423.png)



读和写

![image-20250220214345601](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220214345601.png)



![image-20250220214510241](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220214510241.png)

![image-20250220214532639](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220214532639.png)

![image-20250220214630801](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220214630801.png)

CR1寄存器

![image-20250220214723887](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220214723887.png)

![image-20250220214746150](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220214746150.png)



jie口函数

![image-20250220214819112](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220214819112.png)

![image-20250220214914087](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220214914087.png)

![image-20250220215005323](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220215005323.png)

![image-20250220215211479](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220215211479.png)



代码





![image-20250220220415697](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220220415697.png)



![image-20250220220446782](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220220446782.png)

![image-20250220220726160](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220220726160.png)





#### 27.第27讲  串口通信实验讲解

![image-20250220221059289](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250220221059289.png)

#### 28. 第二十八讲  外部中断

![image-20250221202129023](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250221202129023.png)



![image-20250221203253100](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250221203253100.png)

![image-20250221203544553](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250221203544553.png)

![image-20250221203950488](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250221203950488.png)



中断向量（有一些是单独的  有一些是gongying的）

![image-20250221204120061](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250221204120061.png)

![image-20250221204242087](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250221204242087.png)

![image-20250221204356829](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250221204356829.png)





AFIO一定要开启

![image-20250221204457508](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250221204457508.png)





![image-20250221204552939](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250221204552939.png)



![image-20250221205609285](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250221205609285.png)

![image-20250221205641737](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250221205641737.png)

#### 29. 独立看门狗

![image-20250221205948400](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250221205948400.png)



![image-20250221210137963](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250221210137963.png)



![image-20250221210152485](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250221210152485.png)

杜库里看门狗  窗口看门狗

![image-20250221210252058](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250221210252058.png)

![image-20250221210822022](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250221210822022.png)

![image-20250221210914453](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250221210914453.png)





![image-20250221211016396](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250221211016396.png)



![image-20250221211046504](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250221211046504.png)

![image-20250221211110597](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250221211110597.png)

![image-20250221211201096](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250221211201096.png)



![image-20250221211249637](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250221211249637.png)



![image-20250221211325399](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250221211325399.png)



![image-20250221211928009](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250221211928009.png)

#### 30.第三十讲窗口看门狗



#### 31. 通用定时器基本原理

![image-20250221212153981](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250221212153981.png)



![image-20250221212240197](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250221212240197.png)



![image-20250221212907878](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250221212907878.png)





![image-20250221213027839](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250221213027839.png)

![image-20250221213224914](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250221213224914.png)

![image-20250221213413299](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250221213413299.png)

![image-20250221215407077](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250221215407077.png)

![image-20250221220048095](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250221220048095.png)



![image-20250221220129023](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250221220129023.png)

![image-20250221220316413](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250221220316413.png)

![image-20250221220653699](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250221220653699.png)



![image-20250221221016245](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250221221016245.png)

![image-20250221221134360](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250221221134360.png)

#### 32. 定时器中断实验





#### 33. PWM 输出实验





#### 34. 输入捕获实验



#### 41. 第41讲RTC实时时钟——备份区域BKP

![image-20250228104439675](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250228104439675.png)



![image-20250228104635408](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250228104635408.png)

![image-20250228104754750](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250228104754750.png)

![image-20250228104829489](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250228104829489.png)

![image-20250228104858288](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250228104858288.png)

![image-20250228104934155](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250228104934155.png)

 ![image-20250228105215239](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250228105215239.png)

![image-20250228105316988](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250228105316988.png) 

![image-20250228105751982](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250228105751982.png)

![image-20250228105831221](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250228105831221.png)

![image-20250228105932277](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250228105932277.png)

![image-20250228110055679](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250228110055679.png)





![image-20250228110217375](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250228110217375.png)

![image-20250228110306971](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250228110306971.png)

![image-20250228110359539](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250228110359539.png)

![image-20250228110441837](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250228110441837.png)

![image-20250228110526432](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250228110526432.png)

![image-20250228110552178](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250228110552178.png)

![image-20250228110642335](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250228110642335.png)

![image-20250228110805516](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250228110805516.png)

![image-20250228110855584](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250228110855584.png)



![image-20250228110923497](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250228110923497.png)

![image-20250228110949274](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250228110949274.png)





####  RTC实验

#### 待机唤醒的原理和实验讲解

![image-20250228111339324](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250228111339324.png)

![image-20250228111516841](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250228111516841.png)

![image-20250228111613200](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250228111613200.png)

![image-20250228111657836](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250228111657836.png)

![image-20250228111733086](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250228111733086.png)

![image-20250228112058970](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250228112058970.png)

![image-20250228112137219](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250228112137219.png)

![image-20250228112224454](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250228112224454.png)

![image-20250228112237245](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250228112237245.png)









#### 50 DMA基本原理（DiRECT mEMORY ACCESS） 直接存储器访问



![image-20250228153103951](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250228153103951.png)

![image-20250228153225890](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250228153225890.png)





正常数据-》cpu-》复制

现在 DMA开启传输通道 硬件（无中断） 给cpu减负



![image-20250228153431546](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250228153431546.png)

![image-20250228153552859](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250228153552859.png)

![image-20250228153639041](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250228153639041.png)

![image-20250228153730135](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250228153730135.png)





![image-20250228153824339](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250228153824339.png)

![image-20250228153947912](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250228153947912.png)

![image-20250228154004228](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250228154004228.png)

![image-20250228154036674](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250228154036674.png)

![image-20250228154102196](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250228154102196.png)



![image-20250228154359782](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250228154359782.png)

![image-20250228154523148](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250228154523148.png)

https://github.com/jwyang/graph-rcnn.pytorch?tab=readme-ov-filehttps://github.com/jwyang/graph-rcnn.pytorch?tab=readme-ov-file



![image-20250228154648415](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250228154648415.png)

![image-20250228155048087](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250228155048087.png)

![image-20250228155153539](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250228155153539.png)





![image-20250228155308067](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250228155308067.png)

![image-20250228155323706](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250228155323706.png)

![image-20250228155411145](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250228155411145.png)



![image-20250228155419225](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250228155419225.png)

![image-20250228160427417](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250228160427417.png)

![image-20250228160823599](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250228160823599.png)





#### 51.I2C通信实验（tof）



![image-20250228160905239](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250228160905239.png)



![image-20250228161252242](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250228161252242.png)

没有通信时默认拉高

![image-20250228161324603](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250228161324603.png)

![image-20250228161341084](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250228161341084.png)





![image-20250228161421153](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250228161421153.png)

![image-20250228161533790](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250228161533790.png)



![image-20250228161712966](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250228161712966.png)

![image-20250228161759915](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250228161759915.png)

![image-20250228161929466](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250228161929466.png)

![image-20250228162059541](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250228162059541.png)

![image-20250228162630070](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250228162630070.png)

![image-20250228162918319](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250228162918319.png)



#### 52. SPI 接口原理   （陀螺仪）



![image-20250228163359832](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250228163359832.png)



![image-20250228163628021](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250228163628021.png)



![image-20250228163814463](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250228163814463.png)

![image-20250228164247160](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250228164247160.png)



![image-20250228164333937](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250228164333937.png)![image-20250228164413072](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250228164413072.png)





![image-20250228164504861](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250228164504861.png)



![image-20250228164705485](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250228164705485.png)





![image-20250228164730979](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250228164730979.png)

![image-20250228164744466](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250228164744466.png)

![image-20250228165316775](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250228165316775.png)

![image-20250228165340659](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250228165340659.png)

![image-20250228165353034](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250228165353034.png)

![image-20250228165405574](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250228165405574.png)

![image-20250228165552777](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250228165552777.png)



SPI-FLASH(自带的flash) W25Q128

![image-20250228165935988](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250228165935988.png)

![image-20250228170141912](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250228170141912.png)



#### 56 CAN通信实验

![image-20250228170310895](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250228170310895.png)

![image-20250228170539329](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250228170539329.png)





##### 1.基础知识

![image-20250228170812744](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250228170812744.png)

![image-20250228170902113](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250228170902113.png)

![image-20250228170913149](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250228170913149.png)



![image-20250228171108677](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250228171108677.png)

![image-20250228171139692](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250228171139692.png)

![image-20250228171230439](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250228171230439.png)

![image-20250228171343971](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250228171343971.png)

![image-20250228171530785](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250228171530785.png)

![image-20250228171653540](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250228171653540.png)

![image-20250228172458560](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250228172458560.png)

GS-KGC: A generative subgraph-based framework for knowledge graph
completion with large language models





#### FLASH





## 2.正点原子 FreeRTOS



![image-20250303085138359](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250303085138359.png)

中断服务函数是前台系统  while死循环是一个后台系统   （一个while里面调用中断函数）

![image-20250303085450296](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250303085450296.png)



界面 网络  实时性  通信  

![image-20250303085703650](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250303085703650.png)



![image-20250303090533389](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250303090533389.png) 

总是运行优先级最高的

![image-20250303090729067](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250303090729067.png)

![image-20250303091118939](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250303091118939.png)

![image-20250303091247669](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250303091247669.png)

![image-20250303091303200](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250303091303200.png)



![image-20250303094623328](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250303094623328.png)![image-20250303094620543](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250303094620543.png)

解决两个函数  或多个函数 前后台的影响（一个在执行另一个被打断）

![image-20250303101024007](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250303101024007.png)

所以有rtos 多任务系统   （交替执行  反应够快）   每个子任务都是一个while循环 由rtos选择执行哪个循环

![image-20250303100639037](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250303100639037.png)

![image-20250303100710130](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250303100710130.png)

任务调度器（相隔时间较短的交替执行任务）

![image-20250303100834965](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250303100834965.png)

![image-20250303102320618](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250303102320618.png)

![image-20250303102842127](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250303102842127.png)

高优先级有延时等待时  低优先级又可以执行

![image-20250303103305967](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250303103305967.png)

![image-20250303103413683](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250303103413683.png)

![image-20250303103517046](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250303103517046.png)

![image-20250303103747785](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250303103747785.png)

![image-20250303103945421](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250303103945421.png)

![image-20250303104001739](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250303104001739.png)



### 2. FreeRTOS简介

![image-20250303104615476](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250303104615476.png)

![image-20250303104716647](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250303104716647.png)

![image-20250303104729782](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250303104729782.png)

![image-20250303104840021](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250303104840021.png)

有硬件限制   MCU大小 任务栈

![image-20250303104916176](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250303104916176.png)

##### 学习资料

官网   正点  

![image-20250303105255175](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250303105255175.png)

![image-20250303105436166](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250303105436166.png)

一定要先了解cotex-M3内核  M4 权威指南

### 3. 复习

![image-20250303105733075](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250303105733075.png)

![image-20250303105755457](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250303105755457.png)

![image-20250303110105676](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250303110105676.png)



### 3. Freertos的基础知识

![image-20250303110447926](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250303110447926.png)

#### 1.任务调度简介

任务调度算法来决定需要执行的那个任务

![image-20250303110905775](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250303110905775.png)

抢占式（数值越大 优先级越大  stm322  0*-31 ）



时间片调度（时钟节拍）



协程式调度（了解）

![image-20250303110948524](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250303110948524.png)

![image-20250303112130525](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250303112130525.png)

![image-20250303112511924](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250303112511924.png)

![image-20250303112532226](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250303112532226.png)

![image-20250303112637851](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250303112637851.png)

![image-20250303112937197](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250303112937197.png)

![image-20250303113334405](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250303113334405.png)

![image-20250303113342723](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250303113342723.png)

![image-20250303113359308](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250303113359308.png)











#### 2.任务状态 

![image-20250303113610291](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250303113610291.png)

![image-20250303113632477](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250303113632477.png)

![image-20250303113913766](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250303113913766.png)

![image-20250303113952650](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250303113952650.png)

![image-20250303114142720](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250303114142720.png)

![image-20250303114302101](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250303114302101.png)

![image-20250303114341850](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250303114341850.png)

![image-20250303114734036](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250303114734036.png)

![image-20250303114806160](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250303114806160.png)

![image-20250303114911501](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250303114911501.png)

![image-20250303115034178](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250303115034178.png)

#### 3. 课堂总结

![image-20250303141454849](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250303141454849.png)

### 5.知识总结

![image-20250303141454849](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250303141454849.png)

![image-20250303141832953](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250303141832953.png)

![image-20250303141855399](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250303141855399.png)

![image-20250303141937881](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250303141937881.png)

![image-20250303142009637](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250303142009637.png)

![image-20250303142103584](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250303142103584.png)



###  6. 第六讲FreeRTOS源码获取

![image-20250303142238047](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250303142238047.png)

#### 1.源码获取

![image-20250303142353721](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250303142353721.png)

![image-20250303143006237](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250303143006237.png)

![image-20250303143054429](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250303143054429.png)

![image-20250303143206877](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250303143206877.png)

![image-20250303143216181](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250303143216181.png)

![image-20250303143237345](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250303143237345.png)

![image-20250303143335965](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250303143335965.png)



Source包含源码本身 （include FreeRTOS的头文件   portable 移植文件）

还有三个重要的.c文件    list.c  tasks.c,   queue.c 

![image-20250303143415894](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250303143415894.png)

![image-20250303143613347](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250303143613347.png)

![image-20250303143621989](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250303143621989.png)

**protable 连接桥梁**  RTOS与STM32的连接桥梁  操作寄存器

FreeRTOS时软件层面的东西       STM32是一个硬件    之间如何连接 

![image-20250303143842744](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250303143842744.png)

![image-20250303143936187](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250303143936187.png)



portable里面包含的内容  （这里是三个）  IDE(Keil 或clion) MewrMang 内存管理  RVDS （不同内核芯片的移植文件）









###  7.FreeRTOS移植

![image-20250303145721550](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250303145721550.png)

实现正点原子开发板的FreeRTOS移植



源码

基础工程

![image-20250303145856912](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250303145856912.png)



![image-20250303155521547](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250303155521547.png)

![image-20250303155533101](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250303155533101.png)

内存管理实验   timer 



### 8. FreeRTOSConfig.h文件夹

对系统功能进行配置和裁剪   。

![image-20250304172914585](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250304172914585.png)

宏定义 包含三类  INCLUDE  CONFIG  其他

include   配置可选的API函数

config     完成功能配置和裁剪   信号互斥  队列。。。。

其他      pendsc  svc

![image-20250304173058114](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250304173058114.png)

1. configUSE_PREEMPTION 1    # 1 使用抢占式 0  使用协程式

2. configUSE_PORT_OPTIMSED_TASK_SELECTION  1 

![image-20250304173658978](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250304173658978.png)

![image-20250304173724020](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250304173724020.png)

1   硬件 任务优先级最大最大32  效率高

3. configUSE_TICKLESS_IDLE  0

![image-20250304173848716](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250304173848716.png)

4. configCPU_CLOCK_HZ S 

![image-20250304174030532](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250304174030532.png)

5. SYstick 频率  与内核不同时才定义

![image-20250304174347080](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250304174347080.png)

6. 设置滴答定时器的频率

   ![image-20250304174524244](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250304174524244.png)

​		1000HZ 1S

7. 最大优先级数量

![image-20250304174641571](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250304174641571.png)



8. 空闲任务任务堆栈大小  默认128字

![image-20250304174748344](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250304174748344.png)

![image-20250304174835419](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250304174835419.png)



### 11.动态创建任务的原理

![image-20250305153503296](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250305153503296.png)

![image-20250305153613999](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250305153613999.png)

![image-20250305153627571](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250305153627571.png)

![image-20250305154142058](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250305154142058.png)



### 12.静态创建任务





![image-20250305155815564](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250305155815564.png)

![image-20250305170310934](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250305170310934.png)

![image-20250305171345336](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250305171345336.png)

```

```

### 13. FreeRTO的任务挂起与恢复



### 18.Freertos的临界段代码保护

![image-20250306143316551](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250306143316551.png)

 ![image-20250306143445465](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250306143445465.png)

什么场合

1. 外设初始化（IIC SPI）  按照时序初始化的设备

2. 系统自身需求

3. 用户需求

   ![image-20250306143648272](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250306143648272.png)

什么可以打断程序的运行  （ 终中断  任务调度 ）

1. 关中断![image-20250306143806330](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250306143806330.png)

![image-20250306143909667](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250306143909667.png)

![image-20250306144106986](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250306144106986.png)

 中断极

uint_32 save_status;保存中断屏蔽寄存器之前的值

![image-20250306145617186](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250306145617186.png)

成对使用

![image-20250306145812256](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250306145812256.png)

![image-20250306145904563](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250306145904563.png)

我有一个问题



![image-20250306151540480](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250306151540480.png)

![c1354a316a0a8c5eac6362b26e214cd](D:\Program Files\wechat\WeChat Files\wxid_28c7brmd4irv22\FileStorage\Temp\c1354a316a0a8c5eac6362b26e214cd.jpg)

为什么我的osthreadexit()就得放在最后面

放在前面的话里面灯常亮





### 19. 任务调度器的挂起和恢复

![image-20250306153754110](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250306153754110.png)

![image-20250306153845955](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250306153845955.png)

![image-20250306153934200](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250306153934200.png)

![image-20250306153952813](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250306153952813.png)

![image-20250306154031951](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250306154031951.png)

![image-20250306154048305](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250306154048305.png)

  ![image-20250306154636836](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250306154636836.png)



![image-20250306154758065](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250306154758065.png)

通过++Such实现任务调度器的挂起  （不执行pendsv中断）

![image-20250306155009228](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250306155009228.png)

![image-20250306155746141](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250306155746141.png)

![image-20250306155759673](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250306155759673.png)

![image-20250306155824377](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250306155824377.png)



![image-20250306155913080](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250306155913080.png)

![image-20250306155928761](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250306155928761.png)

![image-20250306155951008](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250306155951008.png)

 

### 20. ReeRTOSde列表和列表项



### 21. 列表及列表项相关的API函数介绍（掌握）



### 22. 列表及列表项函数讲解2



### 23. 实验



### 24. 启动任务调度器

![image-20250307090345367](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250307090345367.png)

 ![image-20250307090525491](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250307090525491.png)

1. 2. 创建两个任务（空闲  软件）

3. 关中断（运行第一个任务时开中断）

4. 更新阻塞超时时间  最大

​	将任务调度器的标志设置为已运行	（pdTRUE）

![image-20250307090841064](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250307090841064.png)

​	系统心跳初始为0

5. 统计任务的运行时间（未定义）

6. 调用 xportStartScheduler()



 xportStartScheduler()用于完成启动任务调度器中与硬件相关配置部分以及启动第一个任务

![image-20250307091335705](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250307091335705.png)

1. 检测终端配置是否有错误
2. 设置pendsv 和systick的中断优先级

![image-20250307091559876](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250307091559876.png)

3. 设置systick的定时时机1ms

4. 呦FPU的话使能M3没有’  自动保存和回复相关寄存器

   

5. 开始第一个任务  prvportStartFristTask()

   ![image-20250307091948317](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250307091948317.png)



###  25. 启动第一个任务prvPortStartFristTask()

vportSVCHandler

![image-20250307092118543](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250307092118543.png)![image-20250307093812405](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250307093812405.png)

1. 

![image-20250307093915871](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250307093915871.png)

![image-20250307094002237](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250307094002237.png)

![image-20250307094014556](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250307094014556.png)

![image-20250307094057447](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250307094057447.png)

![image-20250307094141291](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250307094141291.png)

![image-20250307094159638](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250307094159638.png)

prvPortStartFristTask()  初始化启动第一个任务前的环境，主要是重新设置MSP指针，并使能全局中断

![image-20250307094343369](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250307094343369.png)

![image-20250307094515395](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250307094515395.png)

![image-20250307094552750](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250307094552750.png)

![image-20250307094648087](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250307094648087.png)

![image-20250307094709886](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250307094709886.png)

重新更新MSP （更新）

![image-20250307094838666](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250307094838666.png)

使能全局中断

![image-20250307094951092](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250307094951092.png)

触发SVC中断

![image-20250307095059140](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250307095059140.png)

#### vportSVCHandler  SVC中断 只在第一个任务启动一次

 ![image-20250307095255219](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250307095255219.png)

1. 获取当前任务优先级最高的控制块
2. 获取任务栈顶位置给R0![image-20250307095422761](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250307095422761.png)



3. ldmia  出栈恢复现场（r4 -r11, r14）

![image-20250307095637365](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250307095637365.png)

r14  自动分配

![image-20250307095735251](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250307095735251.png)

![image-20250307095918934](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250307095918934.png)

![image-20250307095933169](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250307095933169.png)

![image-20250307100002694](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250307100002694.png)

![image-20250307100047559](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250307100047559.png)

r0指向r0



4. r0 赋值给psp  因为手动之后 退出中断，是通过psp自动出栈r1-r3等继勋奇的值

![image-20250307100306749](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250307100306749.png)

![image-20250307100610677](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250307100610677.png)

4. 使能所有中断 basepri=0 开启所有中断
5. r14 使用PSP进程堆栈指针![image-20250307100928844](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250307100928844.png)

最后通过bx r14指令跳转到PC函数去执行第一个任务

![image-20250307101026590](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250307101026590.png)

![image-20250307101329200](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250307101329200.png)



软件定时器任务是第一个任务

![image-20250307101545327](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250307101545327.png)（)

### 26.任务切换（上） 本质是CPU寄存器的切换

![image-20250307101814038](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250307101814038.png)

![image-20250307101834677](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250307101834677.png)

压栈     出栈

![image-20250307102044256](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250307102044256.png)

![image-20250307102102360](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250307102102360.png)

1. 暂停A  保存A的值 （cpu->A）

2. 恢复现场(B->CPU)

![image-20250307102222945](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250307102222945.png)

上下文切换

![image-20250307102248065](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250307102248065.png)

![image-20250307102346946](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250307102346946.png)

![image-20250307102441207](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250307102441207.png)

![image-20250307102524969](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250307102524969.png)

整个任务切换的过程在PENDsv中断服务函数中实现



#### PendSV的中断是如何触发的

1. 滴答定时器中断调用

2. 相关函数  portYIELD()

   本质上是控制ICSR的28BIT   

![image-20250307102808239](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250307102808239.png)



调用pendsv的过程

1.滴答定时器   启动pendsv

![image-20250307103139805](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250307103139805.png)

![image-20250307103218376](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250307103218376.png)

![image-20250307103247056](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250307103247056.png)

调用时机  1. 阻塞超时 就序列表更新 调用上下文切换

![image-20250307103349512](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250307103349512.png)

时间片

![image-20250307103451767](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250307103451767.png)

![image-20250307103513908](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250307103513908.png)

2. 函数调用   portYIELD()

   ![image-20250307103613346](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250307103613346.png)

#### Pendsv的内部实现

![image-20250307103838734](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250307103838734.png)

自动保存发生在中断外还是中断内（自动压栈还是自动出战都是PSP）

![image-20250307104008533](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250307104008533.png)

![image-20250307104035097](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250307104035097.png)

自动保存后psp指向R0

![image-20250307104216174](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250307104216174.png)

获取当前任务快的栈顶指针地址（获取R2是为了入栈后将r0的地址给这个栈的栈定指针  方便后续操作 ）r2是pxTOPOFSrack 的地址（r2的内容才是任务的栈顶地址）

![image-20250307104636110](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250307104636110.png)

![image-20250307104236403](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250307104236403.png)

![image-20250307104449864](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250307104449864.png)













### 27.任务切换（下）接着上一节讲的



M3内核没有这段话

![image-20250307105123302](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250307105123302.png)

stmdb压栈

![image-20250307105208762](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250307105208762.png)

r0 ,[r2]



![image-20250307105322949](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250307105322949.png)

![image-20250307105750442](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250307105750442.png)

然后关中断  查找下一个任务的控制块

![image-20250307105845974](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250307105845974.png)





保存现场完毕  -》恢复现场任务B



![image-20250307110017676](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250307110017676.png)

当前优先最最高的任务控制块

![image-20250307105945071](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250307105945071.png)

然后r0清0开中断

![image-20250307110124085](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250307110124085.png)

然后  r0  r3出栈 获取当前PCB‘ r3村的是但当前最高优先级的控制块-》r0新任务的栈顶地址

![image-20250307110209550](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250307110209550.png)

出栈

![image-20250307110410681](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250307110410681.png)

r14 etc_return



然后r0给psp 自动恢复其他寄存器

![image-20250307110519995](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250307110519995.png)

bx14  运行任务B的函数

#### 任务切换函数

<img src="C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250307110702473.png" alt="image-20250307110702473" style="zoom:100%;" />



1. 

![image-20250307110750469](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250307110750469.png)

硬件前导置零

![image-20250307110836887](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250307110836887.png)

![image-20250307110934393](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250307110934393.png)

首先利用前导置零获取任务的就序列表

![image-20250307110953628](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250307110953628.png)

![image-20250307111310314](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250307111310314.png)

![image-20250307111353002](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250307111353002.png)

#####  从就序列表中获取任务的控制块（时间片调度）



<img src="C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250307111455408.png" alt="image-20250307111455408" style="zoom:67%;" />



正常指向最后一个  但是我们要的是最高的  所以是 

![image-20250307111708799](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250307111708799.png)

![image-20250307111841987](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250307111841987.png)



pxindex是会切换的  根据pendsv

不会运行末尾列表项  默认会执行末尾的下一个



### 28.任务调度课堂总结

![image-20250307112528255](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250307112528255.png)

![image-20250307112613808](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250307112613808.png)

![image-20250307112702217](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250307112702217.png)

![image-20250307112735163](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250307112735163.png)

![image-20250307112756734](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250307112756734.png)



任务切换

![image-20250307112812090](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250307112812090.png)

![image-20250307112836180](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250307112836180.png)



![image-20250307112933056](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250307112933056.png)

![image-20250307112955413](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250307112955413.png)

![image-20250307113019559](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250307113019559.png)



![image-20250307113038158](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250307113038158.png)

### 29 时间片调度

![image-20250307143041201](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250307143041201.png)

（时间片调度和抢占式调度的区别）

同等优先级 轮流享有

![image-20250307143146529](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250307143146529.png)

  

如果一个时间片未执行完（下一次到的时候继续执行为执行的） 每个人任务有一个时间片

![image-20250307143704447](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250307143704447.png)

遇到阻塞和信号量  不到一个时间片（切换到task1 ）立马丢弃

![image-20250307143914640](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250307143914640.png)

![image-20250307144013325](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250307144013325.png)

阻塞的时候当前栈应该是保存的 因为有上下文切换，会保存现场和恢复现场

print打印时可能出现戳乱  打印一半给强制打断了  很正常（加上临界区就好了）  那打断的下一次会不会街上

![image-20250307145016282](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250307145016282.png)

可能打印4-5次   这是因为 任务调度记录了上一次末尾寄存器的数值，所以当下一次任务来可能多打几次  要是每次都从头来过的话应该每次都只打印四次

![image-20250307145348574](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250307145348574.png)

![image-20250307145958280](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250307145958280.png)

### 30.任务状态查询相关API函数详解（非常多  不介绍源码如何实现   重点在使用） 资料里面的函数全



并不是很关键  （在调试阶段可能用得多）

作用 功能   实验  使用

热播

![image-20250307150531111](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250307150531111.png)

![image-20250307150601759](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250307150601759.png)

 ![image-20250307150729103](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250307150729103.png)

 ![image-20250307150836148](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250307150836148.png)



![image-20250307151218937](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250307151218937.png)



1. 任务状态查询
2. 

![image-20250307151427490](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250307151427490.png)

1. 获取指定任务的优先级函数 uxTaskPriorityGet( 句柄)

   ![image-20250307151747805](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250307151747805.png)

   ![image-20250307151908279](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250307151908279.png)

2. 设置任务优先级  

 ![image-20250307152435560](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250307152435560.png)

NULL代表自身 

3. 获取任务数量（包含  空任务和软中断任务）

   ![image-20250307160619861](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250307160619861.png)

4. 获取系统中所有任务的任务状态信息，

![image-20250307161443613](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250307161443613.png)

![image-20250307161717786](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250307161717786.png)

结构体  申请一个内存 

![image-20250307162038115](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250307162038115.png)

![image-20250307163243789](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250307163243789.png)

5. 获取单个任务的信息

   ![image-20250307163311257](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250307163311257.png)

句柄  内存 任务栈历史最小值  任务状态

![image-20250307163402383](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250307163402383.png)

![image-20250307164717942](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250307164717942.png)

![image-20250307164908109](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250307164908109.png)

![image-20250307165033412](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250307165033412.png)

![image-20250307165043616](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250307165043616.png)

6. 获取当前任务的任务句柄

   ![image-20250307165242118](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250307165242118.png)



7. 通过任务名获取任务句柄

   ![image-20250307165315533](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250307165315533.png)

8. 获取指定任务的任务栈历史最小剩余堆栈

   ![image-20250307165708349](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250307165708349.png)

taskgetstackhighwatermark

![image-20250307165845349](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250307165845349.png)

![image-20250307165937866](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250307165937866.png)

![image-20250307170104396](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250307170104396.png)

9. 获取任务运行状态

   ![image-20250307170139617](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250307170139617.png)

10. 以表格的形式获取系统中任务信息



![image-20250307170401933](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250307170401933.png)

![image-20250307170412181](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250307170412181.png)

![image-20250307170636326](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250307170636326.png)



![image-20250307170745137](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250307170745137.png)

<img src="C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250307170828475.png" alt="image-20250307170828475" style="zoom:150%;" />

![image-20250307170929905](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250307170929905.png)



###  31.任务时间统计API函数实现

四个宏定义（两个定义为1 一个定义函数 一个定义时间返回值） 星耀定义一个time作为时基函数 10~100um初始化清零 在中断++，

![image-20250313084808570](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250313084808570.png)

![image-20250313084831816](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250313084831816.png)

![image-20250313084912815](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250313084912815.png)

![image-20250313084940774](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250313084940774.png)

###  32 时间管理延时函数

1. 相对  绝对演示



2. 内部如何实现

![image-20250313085119382](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250313085119382.png)

 ![image-20250313085400679](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250313085400679.png)

相对延时从delay运行时间开始

绝对  是从头开始一直到任务结束（包括 任务主题 延时 其他任务）

![image-20250313085532883](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250313085532883.png)







#### 相对延时讲解源码过程

挂起

1. 判断延时时间》0
2. 调度vtasksuppendall(挂起)
3. 调用hanshu![image-20250313085850475](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250313085850475.png)

将当前任务移到阻塞列表

{

```
1. 讲当前任务快从状态列表项中移除（判断是否有同等优先级，若没有同等优先级了） 优先级复位 
```

![image-20250313090107890](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250313090107890.png)

```
2.如果延时时间太大 oxfffff 直接挂起死等
```

![image-20250313090257808](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250313090257808.png)

```
3.否则  记录一下时间（当前时钟（开始）+延时时间）
然后讲数值写道列表项中（用于后面升序排列阻塞列表）
判断 等待时间《当前时间  代表溢出（加入到溢出阻塞列表） 
```

![image-20250313090358914](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250313090358914.png)

```
 4. 否则插入到阻塞列表
 如果当前的预计阻塞时间《下一个阻塞时间  （那就更新一下）
```

![image-20250313090807877](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250313090807877.png)

![image-20250313090834858](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250313090834858.png)

}



解除



1. 在滴答定时器中断里面

![image-20250313091119985](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250313091119985.png)

![image-20250313090956036](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250313090956036.png)



```
1. 调度器没被挂起  首先系统实拍加1  如果现在系统时钟节拍时间溢出（交换就序列表和等待就序列表）

```

![image-20250313091147700](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250313091147700.png)

![image-20250313091426988](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250313091426988.png)

```
2.如果当前系统实拍记录纸》=第一个任务阻塞时间
判断阻塞列表中是否有任务（没有设最大）
有 获取第一个成员任务快-》获取阻塞时间数值
```

![image-20250313091617674](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250313091617674.png)

![image-20250313091718552](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250313091718552.png)

```
3.如果系统时钟节拍《第一个任务的阻塞值（异常 ）
否则真正的到了阻塞时间（从阻塞列表中移除） 事件列表也移除
加到到就序列表
任务切换
```

![image-20250313091809162](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250313091809162.png)

![image-20250313092159895](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250313092159895.png)

![image-20250313092314412](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250313092314412.png)

![QQ_1741829016477](C:\Users\86183\AppData\Local\Temp\QQ_1741829016477.png)



### 33 延时函数演示实验

![image-20250313094017380](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250313094017380.png)

利用波形来看 两个  相对延时和绝对延时函数

优先级涉及

两个参数 （上一次的唤醒时间   唤醒时间）  第一次给要有个初始值 ![image-20250313094356364](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250313094356364.png)

![image-20250313094418555](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250313094418555.png)

![image-20250313094500977](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250313094500977.png)

当前系统时钟揭牌暨录制

![image-20250313094541656](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250313094541656.png)



![image-20250313094730552](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250313094730552.png)



![image-20250313094744983](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250313094744983.png)

![image-20250313095252460](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250313095252460.png)

![image-20250313095306134](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250313095306134.png)

![image-20250313095333375](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250313095333375.png)

![image-20250313095556170](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250313095556170.png)

### 34 消息队列

![image-20250313095734044](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250313095734044.png)



队列是任务到任务 任务到中断 中断到任务的数据交流机制（消息队列）





（能不能用volite关键字  当多个任务同时操作一个变量的时候）

![image-20250313095907708](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250313095907708.png)

![image-20250313100010002](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250313100010002.png) 

 ![image-20250313100544321](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250313100544321.png)



![image-20250313100813632](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250313100813632.png)



同时给hi写队列

![image-20250313101211742](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250313101211742.png)

![image-20250313101231228](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250313101231228.png)

不同的任务在写队列的时候是不可以被打断的 

对队列也有临界区





![image-20250313101332272](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250313101332272.png)

就是做了一个 全局数组的 临街的封装

![image-20250313101408886](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250313101408886.png)

床火箭队列是就自己致电给队列长度和大小







![image-20250313101728543](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250313101728543.png)





1. 数据入队出队（先进先出）

   ![image-20250313101824797](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250313101824797.png)

2. 数据传递的方式（实际值  不是地址） 拷贝数据

   ![image-20250313101943212](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250313101943212.png)

传递至可能会被改变值 不行的

![image-20250313102058814](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250313102058814.png)

3. 多任务访问

   ![image-20250313102116671](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250313102116671.png)

4. 出队入队阻塞（队列已满 设置阻塞时间  （有位置就写 没位置就退出不屑））

![image-20250313102158550](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250313102158550.png)

![image-20250313102247422](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250313102247422.png)

出对阻塞  （没数据）

入队阻塞（从就序列表 一出道 阻塞列表   事件列表项（包含该任务的全部信息） 挂载到等待发送）

![image-20250313102504081](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250313102504081.png)

![image-20250313102936262](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250313102936262.png)



多任务同时等待（ 优先级  时间久）

![image-20250313103055811](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250313103055811.png)

![image-20250313103130669](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250313103130669.png)

队列基本操作和过程

1. 创建
2. 写入消息



怎么判断前面的数据就是任务B想要的数据

![image-20250313103239038](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250313103239038.png)



### 35 队列结构体 相关API

![image-20250313103407914](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250313103407914.png)

 每一个消息

1. 队列项的起始地址 存储区域的起始位置
2. 下一个写入的位置
3. 联合体 （队列  互斥量）  （存储区域的结束地址 对后一个读取队列的地址）
4. 等待发送列表
5. 邓婕接受列表
6. 非空闲队列项目（空）
7. 队列长度
8. 队列项目大小（字节）
9. 读取上锁 （操作不了两个链表）
10. 写上锁   （操作不了两个链表）



![image-20250313103937994](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250313103937994.png)

![image-20250313104011779](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250313104011779.png)

![image-20250313104042386](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250313104042386.png)



队列分为两部分（队列项存储区域 员工   还有整个队列的管理层 队列结构体）

#### 队列相关API函数介绍

1. 创建对列（两个API函数 ） 队列想大小  长度

   动态床架 （自动）                 静态床架        

​		xQueueCreate()                      xQueueCreateStatic()

![image-20250313105247176](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250313105247176.png)

![image-20250313105352652](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250313105352652.png)

成功返回句柄



后面有个宏  队列选择base

![image-20250313105503077](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250313105503077.png)





1. 写队列、（任务即  中断极）

![image-20250313105545434](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250313105545434.png)

![image-20250313105633575](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250313105633575.png)

![image-20250313105953992](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250313105953992.png)

写入调用的同一个函数（   不同的参数xQueueGenericSend()   ）



![image-20250313110140824](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250313110140824.png)

![image-20250313110309185](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250313110309185.png)

![image-20250313110331957](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250313110331957.png) 

![image-20250313110421095](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250313110421095.png)







1. 读队列（任务  中断）

   ![image-20250313110729168](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250313110729168.png)

pop   peek

读  删   制度



san而三叔  队列 缓存 阻塞时间

![image-20250313110855211](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250313110855211.png)

![image-20250313110936944](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250313110936944.png)

![image-20250313111011768](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250313111011768.png)



### 36 队列操作实验

实现队列的入队和出队

![image-20250313111210837](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250313111210837.png)

![image-20250313111315700](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250313111315700.png)

实际值和地址入队  出队



```
1.创建队列
红之一
char buff[100]=['''''']
小数据=xqueueCreate(两个按键队列长度就=2，itemsize(sizeof(uint-8)));
大数据=xqueueCreate(大数组的地址=1，itemsize(sizeof(char *));


入队
task1{
uint_8 key=0

wehile(10)
{
   key=key_scan(0);
   if kyy== || key1{
   xqueuesend(xiaoshuju,&key,死等)
   }
   osdelay(10);
}

}
小队列出对
task2
{
while()
{
xqueuereceive(小人物，&key,zuse )   //不掩饰也可以 本身就有阻塞

}
}


task3
{

}





```



![image-20250313113935216](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250313113935216.png)

![image-20250313114117032](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250313114117032.png)

![image-20250313114137667](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250313114137667.png)





![image-20250313113901355](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250313113901355.png)

![image-20250313113841698](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250313113841698.png)



### 37.创建队列函数解析

![image-20250313162632577](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250313162632577.png)

 动态创建

![image-20250313162809590](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250313162809590.png)

![image-20250313162848034](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250313162848034.png)

```
1.计算队列向存储区总提大小
2.队列首地址=申请队列内存（结构体+队列项）malloc  
3.判断内存是否申请成功，成功就找到列想1的首地址
4.调用prvInitialseNewQueue()初始化新队列

```



![image-20250313163114543](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250313163114543.png)



![image-20250313163241208](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250313163241208.png)

![image-20250313163253419](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250313163253419.png)

![image-20250313163614070](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250313163614070.png)

![image-20250313163914616](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250313163914616.png)

![image-20250313164503382](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250313164503382.png)





![image-20250313164306634](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250313164306634.png)

![image-20250313164410151](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250313164410151.png)





![image-20250313163420507](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250313163420507.png)







相关笔记

https://gitee.com/xrbin/FreeRTOS_learning/blob/master/FreeRTOS10.4.6/01-%E7%AC%94%E8%AE%B0/13-FreeRTOS%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97.md#9%E9%98%9F%E5%88%97%E5%88%9B%E5%BB%BA%E5%86%99%E5%85%A5%E5%92%8C%E8%AF%BB%E5%87%BA%E8%BF%87%E7%A8%8B

### 38. 入队函数(建议看脑图) 都是调用一个函数

尾部（2） 头部  复写队列

![image-20250313165022247](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250313165022247.png)

![image-20250313165135292](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250313165135292.png)



```
1.先关中断临界区
 2.如果有空闲位置或者复写
 {
 复制数据到队列（句柄数据位置）
 	{
 	 环形操作
         {头
         尾
         覆写
         }
 	}
 判断灯带接我收坑列表是都有任务
     {
		移除等待接收世界列表
		{从阻塞列表一处  加到就序列表}
     }
 		
 }
 
 
 如果没有位置
 
 {
 
 
 }
 
```





![image-20250313171539350](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250313171539350.png)

![image-20250313171722112](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250313171722112.png)

![image-20250313171916180](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250313171916180.png)

![image-20250313173025203](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250313173025203.png)





### 39 出队函数解析



![image-20250313173759300](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250313173759300.png)

![image-20250313190412050](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250313190412050.png)





```
关中断
2.有数据
{
	首先找到第一个列表项的位置哦
	拷贝数据（）
	非空闲数据减一
	富国等待发送列表有东西哦（删除时间里表象，删除状态李彪、添加到就序列掉中（如果进度管理为被挂起）任务切换....）
}
推出临界区

没数据
```

![image-20250313190620023](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250313190620023.png)

![image-20250313191145479](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250313191145479.png)

![image-20250313191212396](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250313191212396.png)



mei数据

![image-20250313191253320](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250313191253320.png)







总结：

![image-20250313191739848](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250313191739848.png)

![image-20250313191918754](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250313191918754.png)



![image-20250313191956359](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250313191956359.png)





### 40.信号量的简介

![image-20250313192856736](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250313192856736.png)

信号-》发送状态

（0 1 ）数值信号量

（11111）计数型信号量





队列-》（发送数据）



![image-20250313193049679](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250313193049679.png)

#### 信号量简介

解决同步问题的机制（解决完一件事 给你通知去解决下一件事）  可实现对共享资源的有序访问（）

![image-20250313193333542](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250313193333542.png)

信号量有资源   没资源

空车位就是信号量的资源数（计数值）

释放信号量 （计数值++）

获取信号量（ji-- ）

![image-20250313193509285](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250313193509285.png)



![image-20250313193606266](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250313193606266.png)

![image-20250313193649500](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250313193649500.png)

![image-20250313193700227](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250313193700227.png)

![image-20250313193735988](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250313193735988.png)

![image-20250313193924644](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250313193924644.png)

![image-20250313193945343](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250313193945343.png)



### 41.二值信号量  （实验）

0 1 

第一列长度尾1的对量

![image-20250313194220055](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250313194220055.png)

互斥访问（m 梦和钥匙  唯一  但是涉及到优先级反转的问题）和任务同步（两个任务其中一个必须等下一个完成）



与互斥信号量类似（解决优先级反转）

![image-20250313194513488](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250313194513488.png)

![image-20250313194705164](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250313194705164.png)

xSemaphhoreGive

xSemaphhoreTake



![image-20250313194758754](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250313194758754.png)



信号量的获取可以有阻塞   但是释放没有

![image-20250313194919335](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250313194919335.png)





#### 创建

![image-20250313195022863](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250313195022863.png)

![image-20250313195105966](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250313195105966.png)



有返回值句柄                  （队列长度 1   列表项大小0    类型）

![image-20250313195524743](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250313195524743.png)

![image-20250313195550385](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250313195550385.png)

#### 释放

返回值   xSemaphoreGive(二值信号量)

![image-20250313195953855](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250313195953855.png)

队列结构体中非空闲的队列项的数目就是二值信号量是否有资源（计数值++就代表有信号）

![image-20250313200312082](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250313200312082.png)

![image-20250313200330041](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250313200330041.png)

####  获取

![image-20250313200354192](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250313200354192.png)

![image-20250313200459246](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250313200459246.png)





#### 实验

释放信号量就是对  非空闲的队列项+1  释放成功返回pdpass

只有当 非空闲的队列项《1 才可以释放》=1时失败

![image-20250313202402316](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250313202402316.png)

![image-20250313202927403](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250313202927403.png)

死等本身就阻塞了不用延时





发生了抢占





![QQ_1741869139322](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250313203254489.png)

获取--

![image-20250313203801469](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250313203801469.png)



### 42.计数型信号量

![image-20250313203835155](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250313203835155.png)

计数型队列长度》1

 

![image-20250313204313127](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250313204313127.png)

资源数   =》计数值 表示 （》0有资源  =0没资源）

队列长度 限制计数值的最大上限（使用时间技术   资源管理）

卖包子



初始化   （初始值  上限值）



![image-20250313204627451](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250313204627451.png)

资源管理  停车位



![image-20250313204720903](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250313204720903.png)

资源管理（停车  一般初始值设置为最大）

#### 创建

![image-20250313204819215](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250313204819215.png)

计数型可定是有值的 获取值

![image-20250313204852766](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250313204852766.png)

![image-20250313204916596](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250313204916596.png)

创建  初值和最大值

![image-20250313205016898](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250313205016898.png)

![image-20250313205034350](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250313205034350.png)

x   getcount（句柄）   获取信号量当前大小

![image-20250313205113911](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250313205113911.png)



#### 实验



![image-20250313205203985](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250313205203985.png)

![image-20250313205910240](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250313205910240.png) 



###  43.优先级翻转

二值信号量导致的 优先级反转现象  所以 引出 互斥信号量

现象是高优先级慢执行   低优先级先执行 

![image-20250313211029578](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250313211029578.png)

![image-20250313211751825](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250313211751825.png)

  

L有现货渠道  就会阻塞H  并且中一直运行  搞一只调度不了

![image-20250313211919341](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250313211919341.png)

<img src="C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250313211934204.png" alt="image-20250313211934204" style="zoom:150%;" />

就是 低优先级迟迟不释放信号量  导致高优先级一直在阻塞的，此时中优先级任务一直运行（如果时间很长  ），低优先级释放高优先级才能运行   看起来就像  中优先级比高优先级具有更高的优先权

通过互斥信号量解决

####  实验目的

![image-20250313212225449](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250313212225449.png)



![image-20250313212252568](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250313212252568.png)



![image-20250313213448425](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250313213448425.png)

信号量阻塞高优先级的运行   哈哈哈  唯一一种高出比  透干很重

### 44 互斥信号量 （优先级继承）

![image-20250313213606813](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250313213606813.png)



拥有优先级继承的二值信号量 （解决优先级反转问）



![image-20250313214049274](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250313214049274.png)

他娘的  赖皮（拉高优先级）  保证  中等优先级不抢占高优先级任务

![image-20250313214210268](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250313214210268.png)

![image-20250313214339668](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250313214339668.png)



1. 不能完全消除优先级反转，知识尽量降低优先级反转带来的影响
2. 互斥信号量不能用于终端服务函数中 ， 

![image-20250313214618553](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250313214618553.png)

![image-20250313214628586](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250313214628586.png)





相关API函数

创建（直接内部释放一次，二值没有） ——》获取-》释放

![image-20250313214930850](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250313214930850.png)



![image-20250313214940974](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250313214940974.png)

![image-20250313214958453](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250313214958453.png)



![image-20250313215043386](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250313215043386.png)



#### 实验

![image-20250313215315048](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250313215315048.png)

![image-20250313215542054](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250313215542054.png)

低优先级要在高优先级阻塞的时候拉高





任务同步（必须先做完一个事  才能做下一个   比如按键 按下释放  ）

互斥（两个任务 只能有一个在运行    优先级反转  ）

### 45. 总结





### 46. 队列集

![image-20250314090348232](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250314090348232.png)

队列集： 一个队列只允许一种数据类型（队列想大小）

假设人物之间需要传递不同数据类型之间的消息，使用多个队列（数据类型不同）

队列组合成一起就叫队列及



作用 ：对对哦给女孩刘昂换个数据以及仅从监听（被约翰娜由于阻塞装让i）

![image-20250314090825406](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250314090825406.png)

那这样子话 阻塞是谁的（没关系 不耽误）





#### API

xqueuecreateset

addtoset

remove

select

![image-20250314091019576](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250314091019576.png)



chuangjian 只有长度

![image-20250314091115378](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250314091115378.png)





不能有有效消息（不能发放到队列里有消息  只能是空的）

![image-20250314091301785](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250314091301785.png)

![image-20250314091316196](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250314091316196.png)



如果同时发送了消息呢  怎么知道谁先来呢

![image-20250314091722361](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250314091722361.png)

![image-20250314091826482](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250314091826482.png)

###  47.队列及实验

![image-20250314091956752](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250314091956752.png)

![image-20250314092044443](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250314092044443.png)

![image-20250314092104879](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250314092104879.png)

![image-20250314092837602](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250314092837602.png)

![image-20250314093251712](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250314093251712.png)



王队列中写入数据 

实现队列发送 信号量释放

```c++

key=key_scan()
iuf(k0)
{
	//项对队列发送
	xqueuesend(queue_han,&key,maxdelay);
	if(pdpass){}
    else if 
        
	
}
if(k1)
{
    xsemgive(sem_hand)
     pdpass   
}

```

![image-20250314094947829](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250314094947829.png)



读取并打印

```c++
member_handler=xqueueselectfromset(队列集，阻塞时间)
    
if(member_handler=duiliejubing )
{
    实现队列接受
        xqueue_receive(member_handler,buffer,20)
}
if(member_handler=信号量句柄 )
{
    take(member_handler,20);
}



```

![image-20250314094450143](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250314094450143.png)



可以通过判断接收到的消息队列记得句柄对应不同的同步任务

![image-20250314095453630](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250314095453630.png)

### 48. 事件标志组（与信号量的区别在于 可以中断/任务读取（只有0 1 ） 单任务同步和多任务同步）

![image-20250314095751659](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250314095751659.png)

事件 信号量 都是为了解除阻塞的



事件标志位（用一个位表示时间是否发生）

![image-20250314100124291](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250314100124291.png)

![image-20250314100219562](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250314100219562.png)

高八位不能用作表示事件（其他第八位地综艺时间  志伟1 表示发生 0 ）

![image-20250314100612114](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250314100612114.png)

#### 究竟是什么数据类型

![image-20250314100725530](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250314100725530.png)



高八位 控制信息   24位表示事件标志（自定义）

![image-20250314100856430](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250314100856430.png)

广播

![image-20250314101125577](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250314101125577.png)

![image-20250314101237520](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250314101237520.png)





#### API 



![image-20250314101307933](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250314101307933.png)

创建  清零  设置事件   等待事件标志为（其实是获取）

![image-20250314101511334](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250314101511334.png)

```c++
xEventgroupcreat(void) //没有形参  当宏定义设置为0 表示32位
    //返回值类型  句柄 NULL
```



创建

![image-20250314101702602](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250314101702602.png)

清楚

```
句柄  标志位
```

![image-20250314101800167](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250314101800167.png)



设置标志位

```c++
句柄   位bit  //返回事件标志为的值
```

![image-20250314101840721](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250314101840721.png)

![image-20250314101858618](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250314101858618.png)

等待事件标志位API

```
句柄  位 （bit0-23  逻辑或） 等待成功后是否清零  设置全部位还是某个为 阻塞事件
```



![image-20250314102308219](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250314102308219.png)

![image-20250314102349376](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250314102349376.png)

![image-20250314102359314](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250314102359314.png)



同步函数（设置某一个为 同时等待另一个为成立  否则阻塞）

```
时间组   设置为   等待为 则色时间
```

![image-20250314102618225](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250314102618225.png)

![image-20250314102728304](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250314102728304.png)

![image-20250314102814639](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250314102814639.png)



### 49 事件标志组实验’

![image-20250314104239808](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250314104239808.png)

```c++
三个任务 
动态创建eventgrouphandl=（xeventgroupcreate）
if(!=null)
{创建成功}

模拟事件发生
task01{
        if(key0)
        {
        xeventgroupsetbits(句柄，0x01);  // 1<<0
        }
        else if(key1)
        {
    xeventgroupsetbits(句柄，0x02);  // 1<<1
        }

    }
task2 //等多个标志位
{
        fanhuizhi =xeventgroupwaitbits(句柄，ox01|0x02,pdtrue,pdtrue,maxdelay)

    
    
    
}


```

![image-20250314110327041](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250314110327041.png)



![image-20250314105903353](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250314105903353.png)

![image-20250314105815796](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250314105815796.png)

火起来打印03 

#### 总结

![image-20250314110351404](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250314110351404.png)

![image-20250314110458360](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250314110458360.png)

![image-20250314110601839](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250314110601839.png)



![image-20250314110616847](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250314110616847.png)



### 50. 任务通知简介

![image-20250314110741581](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250314110741581.png)







## 3.Freertos 韦东山入门



![image-20250303101129773](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20250303101129773.png)



